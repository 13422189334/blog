(window.webpackJsonp=window.webpackJsonp||[]).push([[71],{482:function(e,t,a){"use strict";a.r(t);var v=a(25),i=Object(v.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("ul",[a("li",[e._v("keep-alive 有什么作用？")])]),e._v(" "),a("p",[e._v("使用 <"),a("strong",[e._v("keep-alive")]),e._v("> 会将数据保留在内存中，如果要在每次进入页面的时候获取最新的数据，需要在activated阶段获取数据，承担原来created钩子中获取数据的任务。\n被包含在 <"),a("strong",[e._v("keep-alive")]),e._v("> 中创建的组件，会多出两个生命周期的钩子: activated 与 deactivated")]),e._v(" "),a("ul",[a("li",[e._v("keep-alive 在vue的生命周期中赋予了什么新的钩子？")])]),e._v(" "),a("p",[e._v("activated：在组件第一次渲染时也会被调用，之后每次keep-alive激活时被调用。")]),e._v(" "),a("p",[e._v("deactivated：在组件被停用时调用。")]),e._v(" "),a("p",[e._v("注意：只有组件被 keep-alive 包裹时，这两个生命周期才会被调用，如果作为正常组件使用，是不会被调用，以及在 2.1.0 版本之后，使用 exclude 排除之后，就算被包裹在 <"),a("strong",[e._v("keep-alive")]),e._v("> 中，这两个钩子依然不会被调用！另外在服务端渲染时此钩子也不会被调用的。")]),e._v(" "),a("ul",[a("li",[e._v("什么时候获取数据？")])]),e._v(" "),a("p",[e._v("当引入 keep-alive 的时候，页面第一次进入，钩子的触发顺序created -> mounted-> activated，退出时触发deactivated。当再次进入（前进或者后退）时，只触发activated。")]),e._v(" "),a("p",[e._v("我们知道 keep-alive 之后页面模板第一次初始化解析变成HTML片段后，再次进入就不在重新解析而是读取内存中的数据，即只有当数据变化时，才使用VirtualDOM进行diff更新。有需要的话，页面进入的数据获取应该在activated中也放一份。数据下载完毕手动操作DOM的部分也应该在activated中执行才会生效。")]),e._v(" "),a("p",[e._v("所以，有需要的话，应该activated中留一份数据获取的代码，或者不要created部分，直接将created中的代码转移到activated中。")]),e._v(" "),a("h3",{attrs:{id:"注意"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#注意"}},[e._v("#")]),e._v(" 注意")]),e._v(" "),a("blockquote",[a("p",[e._v("created()：在创建vue对象时，当html渲染之前就触发；但是注意，全局vue.js不强制刷新或者重启时只创建一次，也就是说，created()只会触发一次；\nactivated()：在vue对象存活的情况下，进入当前存在activated()函数的页面时，一进入页面就触发；可用于初始化页面数据等")])])])}),[],!1,null,null,null);t.default=i.exports}}]);