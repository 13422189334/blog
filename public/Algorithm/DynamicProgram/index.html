<!DOCTYPE html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-beta.51" />
    <meta name="theme" content="VuePress Theme Hope" />
    <meta property="og:url" content="https://jin-shaohui.gitee.io/sla-blog/Algorithm/DynamicProgram/"><meta property="og:site_name" content="繁华中自律，落魄中自愈"><meta property="og:title" content="动态规划算法"><meta property="og:type" content="article"><meta property="og:updated_time" content="2022-09-16T07:30:02.000Z"><meta property="og:locale" content="zh-CN"><meta property="article:tag" content="很菜的算法"><meta property="article:published_time" content="2022-06-06T16:38:19.000Z"><meta property="article:modified_time" content="2022-09-16T07:30:02.000Z"><meta name="baidu-site-verification" content="nGf5yi0Gec"><link rel="mask-icon" href="/assets/safari-pinned-tab.svg" color="#5c92d1"><title>动态规划算法 | 繁华中自律，落魄中自愈</title><meta name="description" content="Just playing around">
    <style>
      :root {
        --bg-color: #fff;
      }

      html[data-theme="dark"] {
        --bg-color: #1d2025;
      }

      html,
      body {
        background-color: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.querySelector("html").setAttribute("data-theme", "dark");
      }
    </script>
    <link rel="stylesheet" href="/sla-blog/assets/style.980a10a0.css">
    <link rel="modulepreload" href="/sla-blog/assets/app.c75fd66b.js"><link rel="modulepreload" href="/sla-blog/assets/index.html.e8888a5b.js"><link rel="modulepreload" href="/sla-blog/assets/_plugin-vue_export-helper.cdc0426e.js"><link rel="modulepreload" href="/sla-blog/assets/index.html.cb67b2fb.js"><link rel="prefetch" href="/sla-blog/assets/index.html.c92ed914.js"><link rel="prefetch" href="/sla-blog/assets/index.html.28f34471.js"><link rel="prefetch" href="/sla-blog/assets/index.html.e136e12f.js"><link rel="prefetch" href="/sla-blog/assets/index.html.f72fa356.js"><link rel="prefetch" href="/sla-blog/assets/index.html.44629795.js"><link rel="prefetch" href="/sla-blog/assets/index.html.9737d0e4.js"><link rel="prefetch" href="/sla-blog/assets/index.html.61162167.js"><link rel="prefetch" href="/sla-blog/assets/index.html.8e376004.js"><link rel="prefetch" href="/sla-blog/assets/index.html.4df16264.js"><link rel="prefetch" href="/sla-blog/assets/index.html.3ca93f27.js"><link rel="prefetch" href="/sla-blog/assets/index.html.30148379.js"><link rel="prefetch" href="/sla-blog/assets/index.html.cb7843aa.js"><link rel="prefetch" href="/sla-blog/assets/index.html.a94a0007.js"><link rel="prefetch" href="/sla-blog/assets/index.html.e979a062.js"><link rel="prefetch" href="/sla-blog/assets/index.html.dd56afa3.js"><link rel="prefetch" href="/sla-blog/assets/index.html.cad9f976.js"><link rel="prefetch" href="/sla-blog/assets/index.html.b9458f39.js"><link rel="prefetch" href="/sla-blog/assets/index.html.ad8b5020.js"><link rel="prefetch" href="/sla-blog/assets/index.html.17fb8c47.js"><link rel="prefetch" href="/sla-blog/assets/index.html.22bb8072.js"><link rel="prefetch" href="/sla-blog/assets/index.html.b814a5ad.js"><link rel="prefetch" href="/sla-blog/assets/index.html.67c337fc.js"><link rel="prefetch" href="/sla-blog/assets/index.html.f12e0654.js"><link rel="prefetch" href="/sla-blog/assets/index.html.6ae3a21f.js"><link rel="prefetch" href="/sla-blog/assets/index.html.d4c53634.js"><link rel="prefetch" href="/sla-blog/assets/index.html.c5e3d845.js"><link rel="prefetch" href="/sla-blog/assets/index.html.e7888024.js"><link rel="prefetch" href="/sla-blog/assets/index.html.1eb83c33.js"><link rel="prefetch" href="/sla-blog/assets/index.html.41501deb.js"><link rel="prefetch" href="/sla-blog/assets/index.html.9a31f083.js"><link rel="prefetch" href="/sla-blog/assets/index.html.8418834a.js"><link rel="prefetch" href="/sla-blog/assets/index.html.2b18d281.js"><link rel="prefetch" href="/sla-blog/assets/index.html.fa07ca15.js"><link rel="prefetch" href="/sla-blog/assets/index.html.999c0e11.js"><link rel="prefetch" href="/sla-blog/assets/index.html.814eba02.js"><link rel="prefetch" href="/sla-blog/assets/index.html.de34fcd1.js"><link rel="prefetch" href="/sla-blog/assets/index.html.dbbc2766.js"><link rel="prefetch" href="/sla-blog/assets/index.html.a9cc9aba.js"><link rel="prefetch" href="/sla-blog/assets/index.html.37dcd260.js"><link rel="prefetch" href="/sla-blog/assets/index.html.ac8ea7b1.js"><link rel="prefetch" href="/sla-blog/assets/index.html.1de5be28.js"><link rel="prefetch" href="/sla-blog/assets/index.html.43171c02.js"><link rel="prefetch" href="/sla-blog/assets/index.html.88cfb111.js"><link rel="prefetch" href="/sla-blog/assets/index.html.617e0970.js"><link rel="prefetch" href="/sla-blog/assets/index.html.dccb3189.js"><link rel="prefetch" href="/sla-blog/assets/index.html.d80d1ebc.js"><link rel="prefetch" href="/sla-blog/assets/index.html.91b7b9eb.js"><link rel="prefetch" href="/sla-blog/assets/index.html.8a98597c.js"><link rel="prefetch" href="/sla-blog/assets/index.html.1a0ed3a1.js"><link rel="prefetch" href="/sla-blog/assets/index.html.6a8dbe62.js"><link rel="prefetch" href="/sla-blog/assets/index.html.ffb95018.js"><link rel="prefetch" href="/sla-blog/assets/index.html.01a3d7a4.js"><link rel="prefetch" href="/sla-blog/assets/index.html.1845c47d.js"><link rel="prefetch" href="/sla-blog/assets/index.html.15f71e26.js"><link rel="prefetch" href="/sla-blog/assets/index.html.c2a1d042.js"><link rel="prefetch" href="/sla-blog/assets/index.html.f27bf257.js"><link rel="prefetch" href="/sla-blog/assets/index.html.d94d9a86.js"><link rel="prefetch" href="/sla-blog/assets/index.html.154d1339.js"><link rel="prefetch" href="/sla-blog/assets/index.html.bedd2cb2.js"><link rel="prefetch" href="/sla-blog/assets/index.html.d87987fc.js"><link rel="prefetch" href="/sla-blog/assets/index.html.624d57ea.js"><link rel="prefetch" href="/sla-blog/assets/index.html.dd2b7bcb.js"><link rel="prefetch" href="/sla-blog/assets/index.html.45a9f415.js"><link rel="prefetch" href="/sla-blog/assets/index.html.c8226d64.js"><link rel="prefetch" href="/sla-blog/assets/index.html.f440b211.js"><link rel="prefetch" href="/sla-blog/assets/index.html.eaeca5fe.js"><link rel="prefetch" href="/sla-blog/assets/index.html.8f2b53f6.js"><link rel="prefetch" href="/sla-blog/assets/index.html.3a7ad69f.js"><link rel="prefetch" href="/sla-blog/assets/index.html.df222de8.js"><link rel="prefetch" href="/sla-blog/assets/index.html.ff4e391a.js"><link rel="prefetch" href="/sla-blog/assets/index.html.fe3df2c5.js"><link rel="prefetch" href="/sla-blog/assets/index.html.23bded87.js"><link rel="prefetch" href="/sla-blog/assets/index.html.a308f3e3.js"><link rel="prefetch" href="/sla-blog/assets/index.html.bda08570.js"><link rel="prefetch" href="/sla-blog/assets/index.html.ef66b4d8.js"><link rel="prefetch" href="/sla-blog/assets/index.html.b85de8ee.js"><link rel="prefetch" href="/sla-blog/assets/index.html.b1ec6494.js"><link rel="prefetch" href="/sla-blog/assets/index.html.61718931.js"><link rel="prefetch" href="/sla-blog/assets/index.html.3574983e.js"><link rel="prefetch" href="/sla-blog/assets/index.html.8f865b00.js"><link rel="prefetch" href="/sla-blog/assets/index.html.ed987cd2.js"><link rel="prefetch" href="/sla-blog/assets/index.html.f3365be8.js"><link rel="prefetch" href="/sla-blog/assets/404.html.04621f17.js"><link rel="prefetch" href="/sla-blog/assets/index.html.cc7c45f0.js"><link rel="prefetch" href="/sla-blog/assets/index.html.4814b3e3.js"><link rel="prefetch" href="/sla-blog/assets/index.html.471be225.js"><link rel="prefetch" href="/sla-blog/assets/index.html.1066d3be.js"><link rel="prefetch" href="/sla-blog/assets/index.html.26fc0bc1.js"><link rel="prefetch" href="/sla-blog/assets/index.html.099b40d0.js"><link rel="prefetch" href="/sla-blog/assets/index.html.3809b3bd.js"><link rel="prefetch" href="/sla-blog/assets/index.html.3fa48c88.js"><link rel="prefetch" href="/sla-blog/assets/index.html.172fa48c.js"><link rel="prefetch" href="/sla-blog/assets/index.html.6e633c02.js"><link rel="prefetch" href="/sla-blog/assets/index.html.36178fd6.js"><link rel="prefetch" href="/sla-blog/assets/index.html.7d59b377.js"><link rel="prefetch" href="/sla-blog/assets/index.html.674de5c5.js"><link rel="prefetch" href="/sla-blog/assets/index.html.97a88c81.js"><link rel="prefetch" href="/sla-blog/assets/index.html.daaa1c81.js"><link rel="prefetch" href="/sla-blog/assets/index.html.8a93faed.js"><link rel="prefetch" href="/sla-blog/assets/index.html.05ccedd4.js"><link rel="prefetch" href="/sla-blog/assets/index.html.cb0f5a9c.js"><link rel="prefetch" href="/sla-blog/assets/index.html.65d0e34f.js"><link rel="prefetch" href="/sla-blog/assets/index.html.77941ae8.js"><link rel="prefetch" href="/sla-blog/assets/index.html.39f1ccdd.js"><link rel="prefetch" href="/sla-blog/assets/index.html.0292fe81.js"><link rel="prefetch" href="/sla-blog/assets/index.html.ac67a85a.js"><link rel="prefetch" href="/sla-blog/assets/index.html.f69db4dc.js"><link rel="prefetch" href="/sla-blog/assets/index.html.086867b5.js"><link rel="prefetch" href="/sla-blog/assets/index.html.849de2fa.js"><link rel="prefetch" href="/sla-blog/assets/index.html.272e7a7b.js"><link rel="prefetch" href="/sla-blog/assets/index.html.f3bfebca.js"><link rel="prefetch" href="/sla-blog/assets/index.html.926423e9.js"><link rel="prefetch" href="/sla-blog/assets/index.html.81af63fb.js"><link rel="prefetch" href="/sla-blog/assets/index.html.85b1ab4b.js"><link rel="prefetch" href="/sla-blog/assets/index.html.a5c226bc.js"><link rel="prefetch" href="/sla-blog/assets/index.html.1aefd414.js"><link rel="prefetch" href="/sla-blog/assets/index.html.848ee8cb.js"><link rel="prefetch" href="/sla-blog/assets/index.html.52285c7f.js"><link rel="prefetch" href="/sla-blog/assets/index.html.9b47b683.js"><link rel="prefetch" href="/sla-blog/assets/index.html.1641dd73.js"><link rel="prefetch" href="/sla-blog/assets/index.html.81b42692.js"><link rel="prefetch" href="/sla-blog/assets/index.html.9338c20b.js"><link rel="prefetch" href="/sla-blog/assets/index.html.6c31f88d.js"><link rel="prefetch" href="/sla-blog/assets/index.html.f587fe27.js"><link rel="prefetch" href="/sla-blog/assets/index.html.33a228e1.js"><link rel="prefetch" href="/sla-blog/assets/index.html.cb2a665a.js"><link rel="prefetch" href="/sla-blog/assets/index.html.79514cd2.js"><link rel="prefetch" href="/sla-blog/assets/index.html.5dfe0868.js"><link rel="prefetch" href="/sla-blog/assets/index.html.1dd30b0c.js"><link rel="prefetch" href="/sla-blog/assets/index.html.0084d936.js"><link rel="prefetch" href="/sla-blog/assets/index.html.e48bcfd2.js"><link rel="prefetch" href="/sla-blog/assets/index.html.ec22324f.js"><link rel="prefetch" href="/sla-blog/assets/index.html.e21f85e0.js"><link rel="prefetch" href="/sla-blog/assets/index.html.64265ba0.js"><link rel="prefetch" href="/sla-blog/assets/index.html.8e1fc9cc.js"><link rel="prefetch" href="/sla-blog/assets/index.html.7b2547e2.js"><link rel="prefetch" href="/sla-blog/assets/index.html.736d25e1.js"><link rel="prefetch" href="/sla-blog/assets/index.html.ce704c83.js"><link rel="prefetch" href="/sla-blog/assets/index.html.e303e1a0.js"><link rel="prefetch" href="/sla-blog/assets/index.html.ada19408.js"><link rel="prefetch" href="/sla-blog/assets/index.html.5c49459f.js"><link rel="prefetch" href="/sla-blog/assets/index.html.4d648eb5.js"><link rel="prefetch" href="/sla-blog/assets/index.html.988624f4.js"><link rel="prefetch" href="/sla-blog/assets/index.html.a9c2bd7e.js"><link rel="prefetch" href="/sla-blog/assets/index.html.4eb3254f.js"><link rel="prefetch" href="/sla-blog/assets/index.html.bb6e6571.js"><link rel="prefetch" href="/sla-blog/assets/index.html.d7298b7d.js"><link rel="prefetch" href="/sla-blog/assets/index.html.da58873c.js"><link rel="prefetch" href="/sla-blog/assets/index.html.7b211092.js"><link rel="prefetch" href="/sla-blog/assets/index.html.ad0ba7ff.js"><link rel="prefetch" href="/sla-blog/assets/index.html.bf539158.js"><link rel="prefetch" href="/sla-blog/assets/index.html.02f4a287.js"><link rel="prefetch" href="/sla-blog/assets/index.html.be1c3627.js"><link rel="prefetch" href="/sla-blog/assets/index.html.90b4a236.js"><link rel="prefetch" href="/sla-blog/assets/index.html.ff650701.js"><link rel="prefetch" href="/sla-blog/assets/index.html.58e23f46.js"><link rel="prefetch" href="/sla-blog/assets/index.html.f965305b.js"><link rel="prefetch" href="/sla-blog/assets/index.html.cbe093ae.js"><link rel="prefetch" href="/sla-blog/assets/index.html.b651297f.js"><link rel="prefetch" href="/sla-blog/assets/index.html.71f2fe2d.js"><link rel="prefetch" href="/sla-blog/assets/index.html.4f837a8c.js"><link rel="prefetch" href="/sla-blog/assets/index.html.3bfc8052.js"><link rel="prefetch" href="/sla-blog/assets/index.html.4c8af385.js"><link rel="prefetch" href="/sla-blog/assets/index.html.41c6ae71.js"><link rel="prefetch" href="/sla-blog/assets/index.html.621f9cf1.js"><link rel="prefetch" href="/sla-blog/assets/index.html.9f7f3e4b.js"><link rel="prefetch" href="/sla-blog/assets/index.html.d158fb19.js"><link rel="prefetch" href="/sla-blog/assets/index.html.e58294d1.js"><link rel="prefetch" href="/sla-blog/assets/index.html.e4d6913d.js"><link rel="prefetch" href="/sla-blog/assets/index.html.ffc8f10e.js"><link rel="prefetch" href="/sla-blog/assets/index.html.335c2918.js"><link rel="prefetch" href="/sla-blog/assets/index.html.94a64727.js"><link rel="prefetch" href="/sla-blog/assets/index.html.792452fe.js"><link rel="prefetch" href="/sla-blog/assets/index.html.ae55da67.js"><link rel="prefetch" href="/sla-blog/assets/index.html.44caa2ed.js"><link rel="prefetch" href="/sla-blog/assets/index.html.e76b8344.js"><link rel="prefetch" href="/sla-blog/assets/index.html.59a581c5.js"><link rel="prefetch" href="/sla-blog/assets/index.html.efed284c.js"><link rel="prefetch" href="/sla-blog/assets/index.html.6ce98c60.js"><link rel="prefetch" href="/sla-blog/assets/index.html.58526f62.js"><link rel="prefetch" href="/sla-blog/assets/index.html.1ba10d40.js"><link rel="prefetch" href="/sla-blog/assets/index.html.91d8a075.js"><link rel="prefetch" href="/sla-blog/assets/index.html.9f7f7f4f.js"><link rel="prefetch" href="/sla-blog/assets/index.html.3474d3a5.js"><link rel="prefetch" href="/sla-blog/assets/index.html.75a236c0.js"><link rel="prefetch" href="/sla-blog/assets/index.html.0916f8ad.js"><link rel="prefetch" href="/sla-blog/assets/index.html.955b0147.js"><link rel="prefetch" href="/sla-blog/assets/index.html.b4afe200.js"><link rel="prefetch" href="/sla-blog/assets/index.html.94bbdff9.js"><link rel="prefetch" href="/sla-blog/assets/index.html.bcc6b6fd.js"><link rel="prefetch" href="/sla-blog/assets/index.html.7ceecdcb.js"><link rel="prefetch" href="/sla-blog/assets/index.html.ea59bfb5.js"><link rel="prefetch" href="/sla-blog/assets/index.html.d66239a0.js"><link rel="prefetch" href="/sla-blog/assets/index.html.1154d512.js"><link rel="prefetch" href="/sla-blog/assets/index.html.6dbd8520.js"><link rel="prefetch" href="/sla-blog/assets/index.html.2215f1a0.js"><link rel="prefetch" href="/sla-blog/assets/index.html.95f6dc85.js"><link rel="prefetch" href="/sla-blog/assets/index.html.59b0a9c5.js"><link rel="prefetch" href="/sla-blog/assets/index.html.7ca9920b.js"><link rel="prefetch" href="/sla-blog/assets/index.html.5323769c.js"><link rel="prefetch" href="/sla-blog/assets/index.html.2800550f.js"><link rel="prefetch" href="/sla-blog/assets/index.html.07a0a79c.js"><link rel="prefetch" href="/sla-blog/assets/index.html.af378186.js"><link rel="prefetch" href="/sla-blog/assets/index.html.d7ff00a0.js"><link rel="prefetch" href="/sla-blog/assets/index.html.97bf0b95.js"><link rel="prefetch" href="/sla-blog/assets/index.html.dc0e60d7.js"><link rel="prefetch" href="/sla-blog/assets/index.html.832338aa.js"><link rel="prefetch" href="/sla-blog/assets/index.html.ab77cc26.js"><link rel="prefetch" href="/sla-blog/assets/index.html.227cc1aa.js"><link rel="prefetch" href="/sla-blog/assets/index.html.a1598a59.js"><link rel="prefetch" href="/sla-blog/assets/index.html.4fdeba6a.js"><link rel="prefetch" href="/sla-blog/assets/index.html.6b6a3b2d.js"><link rel="prefetch" href="/sla-blog/assets/index.html.5d990279.js"><link rel="prefetch" href="/sla-blog/assets/index.html.0b42ce9a.js"><link rel="prefetch" href="/sla-blog/assets/index.html.767d5940.js"><link rel="prefetch" href="/sla-blog/assets/index.html.555b4cf8.js"><link rel="prefetch" href="/sla-blog/assets/index.html.fc83fc85.js"><link rel="prefetch" href="/sla-blog/assets/index.html.2caa1468.js"><link rel="prefetch" href="/sla-blog/assets/index.html.f954ef11.js"><link rel="prefetch" href="/sla-blog/assets/index.html.af8a3e61.js"><link rel="prefetch" href="/sla-blog/assets/index.html.ad772f77.js"><link rel="prefetch" href="/sla-blog/assets/index.html.33d0d865.js"><link rel="prefetch" href="/sla-blog/assets/404.html.db7884ae.js"><link rel="prefetch" href="/sla-blog/assets/index.html.15a8589a.js"><link rel="prefetch" href="/sla-blog/assets/index.html.986d8a39.js"><link rel="prefetch" href="/sla-blog/assets/index.html.0f193ca9.js"><link rel="prefetch" href="/sla-blog/assets/index.html.10e4a72c.js"><link rel="prefetch" href="/sla-blog/assets/index.html.f3975fa4.js"><link rel="prefetch" href="/sla-blog/assets/index.html.c5ed04df.js"><link rel="prefetch" href="/sla-blog/assets/index.html.ba96a1c6.js"><link rel="prefetch" href="/sla-blog/assets/index.html.5a717420.js"><link rel="prefetch" href="/sla-blog/assets/index.html.7a51645d.js"><link rel="prefetch" href="/sla-blog/assets/index.html.24cb0df6.js"><link rel="prefetch" href="/sla-blog/assets/index.html.2737312a.js"><link rel="prefetch" href="/sla-blog/assets/index.html.36db28b4.js"><link rel="prefetch" href="/sla-blog/assets/index.html.e22e6393.js"><link rel="prefetch" href="/sla-blog/assets/index.html.fc238e0c.js"><link rel="prefetch" href="/sla-blog/assets/index.html.ca2043fd.js"><link rel="prefetch" href="/sla-blog/assets/index.html.6f5bc013.js"><link rel="prefetch" href="/sla-blog/assets/index.html.51ef7d8c.js"><link rel="prefetch" href="/sla-blog/assets/index.html.3fe1e6e3.js"><link rel="prefetch" href="/sla-blog/assets/index.html.c1f8035f.js"><link rel="prefetch" href="/sla-blog/assets/index.html.c8e376d9.js"><link rel="prefetch" href="/sla-blog/assets/index.html.193758e5.js"><link rel="prefetch" href="/sla-blog/assets/index.html.c63a2c19.js"><link rel="prefetch" href="/sla-blog/assets/index.html.e389f628.js"><link rel="prefetch" href="/sla-blog/assets/index.html.37ebc2db.js"><link rel="prefetch" href="/sla-blog/assets/index.html.f6a57601.js"><link rel="prefetch" href="/sla-blog/assets/index.html.cae1cff4.js"><link rel="prefetch" href="/sla-blog/assets/index.html.6435cfbb.js"><link rel="prefetch" href="/sla-blog/assets/index.html.bd2d66f3.js"><link rel="prefetch" href="/sla-blog/assets/index.html.3a2e46b3.js"><link rel="prefetch" href="/sla-blog/assets/index.html.107bffcd.js"><link rel="prefetch" href="/sla-blog/assets/index.html.48b7685b.js"><link rel="prefetch" href="/sla-blog/assets/index.html.9eca7e10.js"><link rel="prefetch" href="/sla-blog/assets/index.html.4102bbec.js"><link rel="prefetch" href="/sla-blog/assets/index.html.ec80bb6d.js"><link rel="prefetch" href="/sla-blog/assets/index.html.ad9b9f43.js"><link rel="prefetch" href="/sla-blog/assets/index.html.cf6f80f3.js"><link rel="prefetch" href="/sla-blog/assets/index.html.3069b6cd.js"><link rel="prefetch" href="/sla-blog/assets/index.html.b04200cc.js"><link rel="prefetch" href="/sla-blog/assets/index.html.322ac34f.js"><link rel="prefetch" href="/sla-blog/assets/index.html.5f314364.js"><link rel="prefetch" href="/sla-blog/assets/index.html.6e2c0269.js"><link rel="prefetch" href="/sla-blog/assets/index.html.0196a685.js"><link rel="prefetch" href="/sla-blog/assets/index.html.b65efda8.js"><link rel="prefetch" href="/sla-blog/assets/index.html.889ebf8d.js"><link rel="prefetch" href="/sla-blog/assets/index.html.be395627.js"><link rel="prefetch" href="/sla-blog/assets/index.html.ab07c35a.js"><link rel="prefetch" href="/sla-blog/assets/index.html.dad2f022.js"><link rel="prefetch" href="/sla-blog/assets/index.html.965b6b21.js"><link rel="prefetch" href="/sla-blog/assets/index.html.9d7b2802.js"><link rel="prefetch" href="/sla-blog/assets/index.html.2917969a.js"><link rel="prefetch" href="/sla-blog/assets/index.html.48d468c3.js"><link rel="prefetch" href="/sla-blog/assets/index.html.bee4d7dd.js"><link rel="prefetch" href="/sla-blog/assets/index.html.f40d3226.js"><link rel="prefetch" href="/sla-blog/assets/index.html.8d0a4453.js"><link rel="prefetch" href="/sla-blog/assets/index.html.61c209c3.js"><link rel="prefetch" href="/sla-blog/assets/index.html.116aea3a.js"><link rel="prefetch" href="/sla-blog/assets/index.html.49d50733.js"><link rel="prefetch" href="/sla-blog/assets/flowchart.parse.ee90d7e0.js"><link rel="prefetch" href="/sla-blog/assets/mermaid.esm.min.b8570279.js"><link rel="prefetch" href="/sla-blog/assets/markdown.esm.832a189d.js"><link rel="prefetch" href="/sla-blog/assets/reveal.esm.b96f05d8.js"><link rel="prefetch" href="/sla-blog/assets/photoswipe.esm.382b1873.js">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="skip-link sr-only">Skip to content</a><!--]--><div class="theme-container has-toc"><!--[--><!--[--><header class="navbar"><div class="navbar-left"><button class="toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!----><a href="/sla-blog/" class="brand"><img class="logo" src="/sla-blog/logo/logo.jpg" alt="繁华中自律，落魄中自愈"><!----><span class="site-name hide-in-pad">繁华中自律，落魄中自愈</span></a><!----></div><div class="navbar-center"><!----><nav class="nav-links"><div class="nav-item hide-in-mobile"><a href="/sla-blog/" class="nav-link" aria-label="首页"><!---->首页<!----></a></div><div class="nav-item hide-in-mobile"><a href="/sla-blog/Knowledge/FrontEnd/" class="nav-link" aria-label="前端知识库"><!---->前端知识库<!----></a></div><div class="nav-item hide-in-mobile"><a href="/sla-blog/Knowledge/BackEnd/" class="nav-link" aria-label="后端知识库"><!---->后端知识库<!----></a></div><div class="nav-item hide-in-mobile"><a href="/sla-blog/DesignPattern/" class="nav-link" aria-label="设计模式"><!---->设计模式<!----></a></div><div class="nav-item hide-in-mobile"><a href="/sla-blog/Algorithm/" class="nav-link active" aria-label="常用算法"><!---->常用算法<!----></a></div><div class="nav-item hide-in-mobile"><a href="/sla-blog/Git/" class="nav-link" aria-label="Git"><!---->Git<!----></a></div><div class="nav-item hide-in-mobile"><a href="/sla-blog/Server/" class="nav-link" aria-label="服务器"><!---->服务器<!----></a></div><div class="nav-item hide-in-mobile"><a href="/sla-blog/Performance/Info/" class="nav-link" aria-label="性能优化"><!---->性能优化<!----></a></div><div class="nav-item hide-in-mobile"><a href="/sla-blog/Recommend/" class="nav-link" aria-label="推荐"><!---->推荐<!----></a></div></nav><!----></div><div class="navbar-right"><!----><!----><!----><div class="nav-item hide-in-mobile"><button class="outlook-button" tabindex="-1" ariahidden="true"><svg xmlns="http://www.w3.org/2000/svg" class="icon outlook-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="outlook icon"><path d="M224 800c0 9.6 3.2 44.8 6.4 54.4 6.4 48-48 76.8-48 76.8s80 41.6 147.2 0 134.4-134.4 38.4-195.2c-22.4-12.8-41.6-19.2-57.6-19.2C259.2 716.8 227.2 761.6 224 800zM560 675.2l-32 51.2c-51.2 51.2-83.2 32-83.2 32 25.6 67.2 0 112-12.8 128 25.6 6.4 51.2 9.6 80 9.6 54.4 0 102.4-9.6 150.4-32l0 0c3.2 0 3.2-3.2 3.2-3.2 22.4-16 12.8-35.2 6.4-44.8-9.6-12.8-12.8-25.6-12.8-41.6 0-54.4 60.8-99.2 137.6-99.2 6.4 0 12.8 0 22.4 0 12.8 0 38.4 9.6 48-25.6 0-3.2 0-3.2 3.2-6.4 0-3.2 3.2-6.4 3.2-6.4 6.4-16 6.4-16 6.4-19.2 9.6-35.2 16-73.6 16-115.2 0-105.6-41.6-198.4-108.8-268.8C704 396.8 560 675.2 560 675.2zM224 419.2c0-28.8 22.4-51.2 51.2-51.2 28.8 0 51.2 22.4 51.2 51.2 0 28.8-22.4 51.2-51.2 51.2C246.4 470.4 224 448 224 419.2zM320 284.8c0-22.4 19.2-41.6 41.6-41.6 22.4 0 41.6 19.2 41.6 41.6 0 22.4-19.2 41.6-41.6 41.6C339.2 326.4 320 307.2 320 284.8zM457.6 208c0-12.8 12.8-25.6 25.6-25.6 12.8 0 25.6 12.8 25.6 25.6 0 12.8-12.8 25.6-25.6 25.6C470.4 233.6 457.6 220.8 457.6 208zM128 505.6C128 592 153.6 672 201.6 736c28.8-60.8 112-60.8 124.8-60.8-16-51.2 16-99.2 16-99.2l316.8-422.4c-48-19.2-99.2-32-150.4-32C297.6 118.4 128 291.2 128 505.6zM764.8 86.4c-22.4 19.2-390.4 518.4-390.4 518.4-22.4 28.8-12.8 76.8 22.4 99.2l9.6 6.4c35.2 22.4 80 12.8 99.2-25.6 0 0 6.4-12.8 9.6-19.2 54.4-105.6 275.2-524.8 288-553.6 6.4-19.2-3.2-32-19.2-32C777.6 76.8 771.2 80 764.8 86.4z"></path></svg><div class="outlook-dropdown"><!----></div></button></div><!----><!----><button class="toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span class="button-container"><span class="button-top"></span><span class="button-middle"></span><span class="button-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow left"></span></div><aside class="sidebar"><!--[--><!----><!--]--><ul class="sidebar-links"><li><!--[--><a href="/sla-blog/Algorithm/Dichotomy/" class="nav-link sidebar-link sidebar-page" aria-label="二分查找理论"><!---->二分查找理论<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-current="page" href="/sla-blog/Algorithm/DynamicProgram/" class="router-link-active router-link-exact-active nav-link active sidebar-link sidebar-page active" aria-label="动态规划算法"><!---->动态规划算法<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/sla-blog/Algorithm/DynamicProgram/#算法认识" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="算法认识"><!---->算法认识<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/sla-blog/Algorithm/DynamicProgram/#算法性质" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="算法性质"><!---->算法性质<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/sla-blog/Algorithm/DynamicProgram/#子问题重叠" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="子问题重叠"><!---->子问题重叠<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/sla-blog/Algorithm/DynamicProgram/#状态转移方程" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="状态转移方程"><!---->状态转移方程<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/sla-blog/Algorithm/DynamicProgram/#最优子结构" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="最优子结构"><!---->最优子结构<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/sla-blog/Algorithm/DynamicProgram/#无后效性" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="无后效性"><!---->无后效性<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/sla-blog/Algorithm/DynamicProgram/#自底向上" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="自底向上"><!---->自底向上<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/sla-blog/Algorithm/DynamicProgram/#步骤实战" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="步骤实战"><!---->步骤实战<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/sla-blog/Algorithm/DynamicProgram/#斐波那契式子" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="斐波那契式子"><!---->斐波那契式子<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/sla-blog/Algorithm/DynamicProgram/#硬币凑钱" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="硬币凑钱"><!---->硬币凑钱<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/sla-blog/Algorithm/DynamicProgram/#例题实战" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="例题实战"><!---->例题实战<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/sla-blog/Algorithm/DynamicProgram/#爬楼梯" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="爬楼梯"><!---->爬楼梯<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/sla-blog/Algorithm/DynamicProgram/#最小路径和" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="最小路径和"><!---->最小路径和<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/sla-blog/Algorithm/DynamicProgram/#不同路径" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="不同路径"><!---->不同路径<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/sla-blog/Algorithm/DynamicProgram/#适用场景" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="适用场景"><!---->适用场景<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/sla-blog/Algorithm/DynamicProgram/#算法局限" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="算法局限"><!---->算法局限<!----></a><ul class="sidebar-sub-headers"></ul></li></ul><!--]--></li><li><!--[--><a href="/sla-blog/Algorithm/PriorityTraversal/" class="nav-link sidebar-link sidebar-page" aria-label="优先遍历算法"><!---->优先遍历算法<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul><!--[--><!----><!--]--></aside><!--[--><main class="page" id="main-content"><!--[--><!----><nav class="breadcrumb disable"></nav><div class="page-title"><h1><!---->动态规划算法</h1><div class="page-info"><span class="author-info" aria-label="作者🖊" data-balloon-pos="down" localizeddate="2022年6月7日" isoriginal="false" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="author icon"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></svg><span><a class="author-item" href="https://jin-shaohui.gitee.io" target="_blank" rel="noopener noreferrer">JSH</a></span><span property="author" content="JSH"></span></span><!----><span class="date-info" aria-label="写作日期📅" data-balloon-pos="down" isoriginal="false" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="calendar icon"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></svg><span>2022年6月7日</span><meta property="datePublished" content="2022-06-06T16:38:19.000Z"></span><span class="category-info" aria-label="分类🌈" data-balloon-pos="down" localizeddate="2022年6月7日" isoriginal="false" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon category-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="category icon"><path d="M148.41 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H148.41c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.311-40.31zM147.556 553.478H429.73c22.263 0 40.311 18.048 40.311 40.31v282.176c0 22.263-18.048 40.312-40.31 40.312H147.555c-22.263 0-40.311-18.049-40.311-40.312V593.79c0-22.263 18.048-40.311 40.31-40.311zM593.927 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H593.927c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.31-40.31zM730.22 920.502H623.926c-40.925 0-74.22-33.388-74.22-74.425V623.992c0-41.038 33.387-74.424 74.425-74.424h222.085c41.038 0 74.424 33.226 74.424 74.067v114.233c0 10.244-8.304 18.548-18.547 18.548s-18.548-8.304-18.548-18.548V623.635c0-20.388-16.746-36.974-37.33-36.974H624.13c-20.585 0-37.331 16.747-37.331 37.33v222.086c0 20.585 16.654 37.331 37.126 37.331H730.22c10.243 0 18.547 8.304 18.547 18.547 0 10.244-8.304 18.547-18.547 18.547z"></path></svg><ul class="categories-wrapper"><li class="category category6 clickable" role="navigation">算法</li><meta property="articleSection" content="算法"></ul></span><span aria-label="标签🏷" data-balloon-pos="down" localizeddate="2022年6月7日" isoriginal="false" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon tag-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="tag icon"><path d="M939.902 458.563L910.17 144.567c-1.507-16.272-14.465-29.13-30.737-30.737L565.438 84.098h-.402c-3.215 0-5.726 1.005-7.634 2.913l-470.39 470.39a10.004 10.004 0 000 14.164l365.423 365.424c1.909 1.908 4.42 2.913 7.132 2.913s5.223-1.005 7.132-2.913l470.39-470.39c2.01-2.11 3.014-5.023 2.813-8.036zm-240.067-72.121c-35.458 0-64.286-28.828-64.286-64.286s28.828-64.285 64.286-64.285 64.286 28.828 64.286 64.285-28.829 64.286-64.286 64.286z"></path></svg><ul class="tags-wrapper"><li class="tag tag7 clickable" role="navigation">很菜的算法</li></ul><meta property="keywords" content="很菜的算法"></span><span class="reading-time-info" aria-label="阅读时间⌛" data-balloon-pos="down" localizeddate="2022年6月7日" isoriginal="false" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="timer icon"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>大约 19 分钟</span><meta property="timeRequired" content="PT19M"></span></div><hr></div><div class="toc-place-holder"><aside id="toc"><div class="toc-header">此页内容</div><div class="toc-wrapper"><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/sla-blog/Algorithm/DynamicProgram/#算法认识" class="router-link-active router-link-exact-active toc-link level2">算法认识</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/sla-blog/Algorithm/DynamicProgram/#算法性质" class="router-link-active router-link-exact-active toc-link level2">算法性质</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/sla-blog/Algorithm/DynamicProgram/#子问题重叠" class="router-link-active router-link-exact-active toc-link level3">子问题重叠</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/sla-blog/Algorithm/DynamicProgram/#状态转移方程" class="router-link-active router-link-exact-active toc-link level3">状态转移方程</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/sla-blog/Algorithm/DynamicProgram/#最优子结构" class="router-link-active router-link-exact-active toc-link level3">最优子结构</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/sla-blog/Algorithm/DynamicProgram/#无后效性" class="router-link-active router-link-exact-active toc-link level3">无后效性</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/sla-blog/Algorithm/DynamicProgram/#自底向上" class="router-link-active router-link-exact-active toc-link level3">自底向上</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/sla-blog/Algorithm/DynamicProgram/#步骤实战" class="router-link-active router-link-exact-active toc-link level2">步骤实战</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/sla-blog/Algorithm/DynamicProgram/#斐波那契式子" class="router-link-active router-link-exact-active toc-link level3">斐波那契式子</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/sla-blog/Algorithm/DynamicProgram/#硬币凑钱" class="router-link-active router-link-exact-active toc-link level3">硬币凑钱</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/sla-blog/Algorithm/DynamicProgram/#例题实战" class="router-link-active router-link-exact-active toc-link level2">例题实战</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/sla-blog/Algorithm/DynamicProgram/#爬楼梯" class="router-link-active router-link-exact-active toc-link level3">爬楼梯</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/sla-blog/Algorithm/DynamicProgram/#最小路径和" class="router-link-active router-link-exact-active toc-link level3">最小路径和</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/sla-blog/Algorithm/DynamicProgram/#不同路径" class="router-link-active router-link-exact-active toc-link level3">不同路径</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/sla-blog/Algorithm/DynamicProgram/#适用场景" class="router-link-active router-link-exact-active toc-link level2">适用场景</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/sla-blog/Algorithm/DynamicProgram/#算法局限" class="router-link-active router-link-exact-active toc-link level2">算法局限</a></li><!----><!--]--></ul></div></aside></div><!----><div class="theme-hope-content"><h2 id="算法认识" tabindex="-1"><a class="header-anchor" href="#算法认识" aria-hidden="true">#</a> 算法认识</h2><p>动态规划（Dynamic Programming）简称 DP，对于子问题重叠的情况特别有效，因为它将子问题的解保存在表格中，当需要某个子问题的解时，直接取值即可，从而避免重复计算。</p><p>动态规划算法通常用于求解具有某种最优性质的问题。在这类问题中，可能会有许多可行解。每一个解都对应于一个值，我们希望找到具有最优值的解。</p><p>动态规划算法与分治法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。</p><p>与分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的。若用分治法来解这类问题，则分解得到的子问题数目太多，有些子问题被重复计算了很多次。如果我们能够保存已解决的子问题的答案，而在需要时再找出已求得的答案，这样就可以避免大量的重复计算，节省时间。我们可以用一个表来记录所有已解的子问题的答案。不管该子问题以后是否被用到，只要它被计算过，就将其结果填入表中。</p><p>所以动态规划实际上是将问题分化成很多的子问题，然后将当前子问题计算过的最优结果存储起来，当另一个子问题也打算求该结果时，直接返回即可，因为已经是最优解。</p><p>动态规划的题目分为两大类，一种是求最优解类，典型问题是背包问题，另一种就是计数类，它们都存在一定的递推性质。前者的递推性质还有一个名字，叫做 「最优子结构」 ——即当前问题的最优解取决于子问题的最优解，后者类似，当前问题的方案数取决于子问题的方案数。所以在遇到求方案数的问题时，我们可以往动态规划的方向考虑。</p><h2 id="算法性质" tabindex="-1"><a class="header-anchor" href="#算法性质" aria-hidden="true">#</a> 算法性质</h2><p>动态规划有很多的「高大上」的术语和性质，这些性质也是算法需要考虑的步骤。</p><h3 id="子问题重叠" tabindex="-1"><a class="header-anchor" href="#子问题重叠" aria-hidden="true">#</a> 子问题重叠</h3><p>子问题重叠性质是指在用递归算法自顶向下对问题进行求解时，每次产生的子问题并不总是新问题，有些子问题会被重复计算多次。动态规划算法正是利用了这种子问题的重叠性质，对每一个子问题只计算一次，然后将其计算结果保存在一个表格中，当再次需要计算已经计算过的子问题时，只是在表格中简单地查看一下结果，从而获得较高的效率。</p><p>也就是在求解的过程中，许多子问题的解被反复地使用。为了避免重复计算，动态规划算法采用了填表来保存子问题解。</p><h3 id="状态转移方程" tabindex="-1"><a class="header-anchor" href="#状态转移方程" aria-hidden="true">#</a> 状态转移方程</h3><p><strong>动态规划最难的就是求解出状态转移方程</strong>，就类似于递推的公式，如：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token function">f</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">f</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span>  <span class="token comment">// n 是 1,2,...,n</span>
dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">]</span>  <span class="token comment">// // i 是 1,2,...,i</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>其中 <code>f(n)</code> 由 <code>f(n - 1)</code> 和 <code>f(n - 2)</code> 不断转移，直至 n 才得到结果，这就是状态转移方程。</p><h3 id="最优子结构" tabindex="-1"><a class="header-anchor" href="#最优子结构" aria-hidden="true">#</a> 最优子结构</h3><p>如果问题的最优解所包含的子问题的解也是最优的，我们就称该问题具有最优子结构性质（即满足最优化原理）。</p><p>原问题的解是由多个子问题的最优解构成，比如说，原问题是考出最高的总成绩，那么子问题就是要把语文考到最高，数学考到最高等，为了每门课考到最高，要把每门课相应的选择题分数拿到最高，填空题分数拿到最高等等，当然，最终就是每门课都是满分，这就是最高的总成绩。所以得到了最后正确的结果：最高的总成绩就是总分。</p><h3 id="无后效性" tabindex="-1"><a class="header-anchor" href="#无后效性" aria-hidden="true">#</a> 无后效性</h3><p>即某阶段状态一旦确定，就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关。</p><p>如 A -&gt; B -&gt; C，那么 B 和 C 的结果不会影响 A，同理 C 不会影响 B，但是 A 能影响 B 和 C，毕竟 B 和 C 是通过 A 的结果来算出。</p><h3 id="自底向上" tabindex="-1"><a class="header-anchor" href="#自底向上" aria-hidden="true">#</a> 自底向上</h3><p>动态规划的特点就是从最底部（0 或者 1）蔓延到上面（n），假设存在长度 n，我们知道递归是从 n 到 n - 1 往下遍历，直至到 1，这叫 <strong>自顶向下</strong>。而动态规划是 <strong>自底向上</strong>，也就是从 1 到 2 往上遍历，直至到 n。</p><p>因为动态规划是自底向上，所以我们在求解的时候需要由一些原始条件，如：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>这样才有具体的值来自底向上：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="步骤实战" tabindex="-1"><a class="header-anchor" href="#步骤实战" aria-hidden="true">#</a> 步骤实战</h2><p>动态规划遵循一套固定的流程：<strong>递归的暴力解法</strong> -&gt; <strong>带备忘录的递归解法</strong> -&gt; <strong>非递归的动态规划解法</strong>。这个过程是层层递进的解决问题的过程，如果没有前面的铺垫，直接看最终的非递归的动态规划解法，会难理解。</p><h3 id="斐波那契式子" tabindex="-1"><a class="header-anchor" href="#斐波那契式子" aria-hidden="true">#</a> 斐波那契式子</h3><p>斐波那契式子为：<code>F(0) = 0，F(1) = 1, F(n) = F(n - 1) + F(n - 2)</code>。</p><h4 id="暴力的递归算法" tabindex="-1"><a class="header-anchor" href="#暴力的递归算法" aria-hidden="true">#</a> 暴力的递归算法</h4><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">fib</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">||</span> n <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token function">fib</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">fib</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 自顶向下</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>要想计算原问题 f(20)，就得先计算出子问题 f(19) 和 f(18)，然后要计算 f(19)，我就要先算出子问题 f(18) 和 f(17)，依次类推。最后遇到 f(1) 或者 f(2) 的时候，结果已知，就能直接返回结果。</p><p>子问题个数为 O(2^n)，所以这个算法的时间复杂度为 O(2^n)，效率很低。</p><p>这就是我们需要解决动态规划问题的第一个性质：<strong>重叠子问题</strong></p><h4 id="带备忘录的递归解法" tabindex="-1"><a class="header-anchor" href="#带备忘录的递归解法" aria-hidden="true">#</a> 带备忘录的递归解法</h4><p>即然耗时的原因是重复计算，那么我们可以造一个「备忘录」，每次算出某个子问题的答案后别急着返回，先记到「备忘录」里再返回；后面每次遇到一个子问题先去「备忘录」里查一查，如果发现之前已经解决过这个问题了，直接把答案拿出来用，不要再耗时去计算了。</p><p>「备忘录」可以是数组，也可以是哈希表，key 为子问题的唯一标识，value 就是解决后的结果。</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">fib</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 备忘录全初始化为 0</span>
  <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> memo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  memo<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  memo<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token comment">// 初始化最简情况</span>
  <span class="token function">fibMemo</span><span class="token punctuation">(</span>memo<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> memo<span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 1 1 2 3 5 8 13，因为 i 从 0 开始，所以 n - 1 就是结果</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">fibMemo</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> memo<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 未被计算过</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> memo<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    memo<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">fibMemo</span><span class="token punctuation">(</span>memo<span class="token punctuation">,</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">fibMemo</span><span class="token punctuation">(</span>memo<span class="token punctuation">,</span> n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> memo<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>带「备忘录」的递归算法，把一棵存在巨量冗余的递归树通过「剪枝」，改造成了一幅不存在冗余的递归图，极大减少了子问题（即递归图中节点）的个数。</p><p>子问题个数为 O(n)。所以，本算法的时间复杂度是 O(n)。比起暴力算法，效率大幅度提升很多。</p><p>至此，带备忘录的递归解法的效率已经和动态规划一样了。实际上，这种解法和动态规划的思想已经差不多了，只不过这种方法叫做「自顶向下」，动态规划叫做「自底向上」，这也是为什么动态规划一般都脱离了递归，而是由循环迭代完成计算。</p><h4 id="动态规划" tabindex="-1"><a class="header-anchor" href="#动态规划" aria-hidden="true">#</a> 动态规划</h4><p>有「备忘录」的启发，我们可以把这个「备忘录」独立出来成为一张表，叫做 dp，在这张表上完成「自底向上」的推算。</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">fib</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 状态转移方程</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 1 1 2 3 5 8 13，因为 i 从 0 开始，所以 n - 1 就是结果</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>dp[i] = dp[i - 1] + dp[i - 2];</code> 就是 <strong>状态转移方程</strong>，它是解决问题的核心。我们也很容易发现，其实状态转移方程直接代表着暴力解法。</p><p><strong>动态规划问题最困难的就是写出状态转移方程</strong>。</p><blockquote><p>动态规划优化</p></blockquote><p>根据斐波那契数列的状态转移方程，当前状态只和之前的两个状态有关，其实并不需要那么长的一个 dp 来存储所有的状态，只要想办法存储之前的两个状态就行了。所以，可以进一步优化，把空间复杂度降为 O(1)：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">fib</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> n<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">int</span> prev <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> curr <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> sum <span class="token operator">=</span> prev <span class="token operator">+</span> curr<span class="token punctuation">;</span>
    prev <span class="token operator">=</span> curr<span class="token punctuation">;</span>
    curr <span class="token operator">=</span> sum<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> curr<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="硬币凑钱" tabindex="-1"><a class="header-anchor" href="#硬币凑钱" aria-hidden="true">#</a> 硬币凑钱</h3><p>给 k 种面值的硬币，面值分别为 c1，c2，...，ck，再给一个总金额 n，问最少需要几枚硬币凑出这个金额，如果不可能凑出，则回答 -1 。</p><p>比如说，k = 3，面值分别为 1，2，5，总金额 n = 11，那么最少需要 3 枚硬币，即 <code>11 = 5 + 5 + 1</code>。</p><h4 id="暴力的递归算法-1" tabindex="-1"><a class="header-anchor" href="#暴力的递归算法-1" aria-hidden="true">#</a> 暴力的递归算法</h4><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">coinChange</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> coins<span class="token punctuation">,</span> <span class="token keyword">int</span> amount<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>amount <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">MAX_VALUE</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> coin <span class="token operator">:</span> coins<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 金额不可达</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>amount <span class="token operator">-</span> coin <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">continue</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">int</span> subProb <span class="token operator">=</span> <span class="token function">coinChange</span><span class="token punctuation">(</span>coins<span class="token punctuation">,</span> amount <span class="token operator">-</span> coin<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 子问题无解时</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>subProb <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">continue</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    ans <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>ans<span class="token punctuation">,</span> subProb <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> ans <span class="token operator">==</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">MAX_VALUE</span> <span class="token operator">?</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">:</span> ans<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>总时间复杂度为 O(k*n^k)。</p><h4 id="带备忘录的递归算法" tabindex="-1"><a class="header-anchor" href="#带备忘录的递归算法" aria-hidden="true">#</a> 带备忘录的递归算法</h4><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">coinChange</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> coins<span class="token punctuation">,</span> <span class="token keyword">int</span> amount<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 备忘录初始化为 -2</span>
  <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> memo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>amount <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span>memo<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  
  <span class="token keyword">return</span> <span class="token function">helper</span><span class="token punctuation">(</span>coins<span class="token punctuation">,</span> amount<span class="token punctuation">,</span> memo<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">helper</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> coins<span class="token punctuation">,</span> <span class="token keyword">int</span> amount<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> memo<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>amount <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 备忘录不为 -2 代表已经存有最优解</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>memo<span class="token punctuation">[</span>amount<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> memo<span class="token punctuation">[</span>amount<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">MAX_VALUE</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> coin <span class="token operator">:</span> coins<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 金额不可达</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>amount <span class="token operator">-</span> coin <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">continue</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">int</span> subProb <span class="token operator">=</span> <span class="token function">helper</span><span class="token punctuation">(</span>coins<span class="token punctuation">,</span> amount <span class="token operator">-</span> coin<span class="token punctuation">,</span> memo<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 子问题无解时</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>subProb <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">continue</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    ans <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>ans<span class="token punctuation">,</span> subProb <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 记录本轮答案，下标就是凑够当前硬币的最少枚次数</span>
  memo<span class="token punctuation">[</span>amount<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>ans <span class="token operator">==</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">MAX_VALUE</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">:</span> ans<span class="token punctuation">;</span>
  <span class="token keyword">return</span> memo<span class="token punctuation">[</span>amount<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="动态规划-1" tabindex="-1"><a class="header-anchor" href="#动态规划-1" aria-hidden="true">#</a> 动态规划</h4><p>如果我们有面值为 1 元、3 元和 5 元的硬币若干枚，如何用最少的硬币凑够 11 元？ (表面上这道题可以用贪心算法，但贪心算法无法保证可以求出解，比如 1 元换成 2 元的时候)</p><p>如何用最少的硬币凑够i元（i &lt; 11）？ 两个原因：</p><ul><li>当我们遇到一个大问题时，总是习惯把问题的规模变小，这样便于分析讨论</li><li>这个规模变小后的问题和原来的问题是同质的，除了规模变小，其它的都是一样的， 本质上它还是同一个问题（规模变小后的问题其实是原问题的子问题）</li></ul><p>当 i = 0，即需要多少个硬币来凑够 0 元。 由于 1，3，5 都大于 0，即没有比 0 小的币值，因此凑够 0 元最少需要 0 个硬币。这时候可以用一个 <strong>标记</strong> 来表示「凑够 0 元最少需要 0 个硬币」。</p><p>那么， 我们用 <code>d(i) = j</code> 来表示凑够 i 元最少需要 j 个硬币。于是我们已经得到了 <code>d(0) = 0</code>，表示凑够 0 元最小需要 0 个硬币。</p><p>当 i = 1 时，只有面值为 1 元的硬币可用，因此我们拿起一个面值为 1 的硬币，接下来只需要凑够 0 元即可，即 <code>d(0) = 0</code>。所以有：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token function">d</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">d</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">=</span> <span class="token function">d</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">=</span> <span class="token number">0</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">=</span> <span class="token number">1</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>当 i = 2 时，仍然只有面值为 1 的硬币可用，于是我拿起一个面值为 1 的硬币，接下来我只需要再凑够 2 - 1 = 1 元即可， 所以有：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token function">d</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">d</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">=</span> <span class="token function">d</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">=</span> <span class="token number">2</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>当 i = 3 时，我们能用的硬币就有两种了：1 元和 3 元。既然能用的硬币有两种，于是就有两种方案。如果我拿了一个 1 元的硬币，我的目标就变为了： 凑够 3 - 1 = 2 元需要的最少硬币数量。即</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token function">d</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">d</span><span class="token punctuation">(</span><span class="token number">3</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">=</span> <span class="token function">d</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">=</span> <span class="token number">3</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这个方案说的是，我拿 3 个 1 元的硬币；第二种方案是我拿起一个 3 元的硬币，我的目标就变成：凑够 3 - 3 = 0元需要的最少硬币数量。即</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token function">d</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">d</span><span class="token punctuation">(</span><span class="token number">3</span> <span class="token operator">-</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">=</span> <span class="token function">d</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">=</span> <span class="token number">0</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">=</span> <span class="token number">1</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这个方案说的是，我拿 1 个 3 元的硬币。</p><p>这两种方案哪种更优呢？题目要求使用用最少的硬币数量来凑够 3 元的。所以，选择 <code>d(3) = 1</code>，所以我们得到了 <strong>转移状态方程</strong>：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token function">d</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span><span class="token function">d</span><span class="token punctuation">(</span><span class="token number">3</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token function">d</span><span class="token punctuation">(</span><span class="token number">3</span> <span class="token operator">-</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>从以上的文字中， 我们要得到动态规划里非常重要的两个概念：<strong>状态</strong> 和 <strong>状态转移方程</strong>。</p><p>上文中 d(i) 表示凑够 i 元需要的最少硬币数量，我们将它定义为该问题的 <strong>状态</strong>， 这个状态是怎么找出来的呢？要根据子问题定义状态，找到子问题，状态也就浮出水面了。最终我们要求解的问题，可以用这个状态来表示：d(11)，即凑够 11 元最少需要多少个硬币。</p><p>那状态转移方程是什么呢？既然我们用 d(i) 表示状态，那么状态转移方程应该包含了状态 d(i)，上文中包含状态 d(i) 的方程是：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token function">d</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span><span class="token function">d</span><span class="token punctuation">(</span><span class="token number">3</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token function">d</span><span class="token punctuation">(</span><span class="token number">3</span> <span class="token operator">-</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>于是它就是状态转移方程，描述状态之间是如何转移的。当然，我们要对它抽象一下，</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token function">d</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span><span class="token function">d</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">d</span><span class="token punctuation">(</span>i <span class="token operator">-</span> vj<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 其中 i-vj &gt;= 0，vj 表示第 j 个硬币的面值</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>所以最终代码：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">coinChange</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> coins<span class="token punctuation">,</span> <span class="token keyword">int</span> amount<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>amount <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span>dp<span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">MAX_VALUE</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> dp<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 内层 for 在求所有子问题 + 1 的最小值</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> coin <span class="token operator">:</span> coins<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">-</span> coin <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">continue</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">1</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> coin<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 状态转移方程</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> dp<span class="token punctuation">[</span>amount<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">MAX_VALUE</span> <span class="token operator">?</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">:</span> dp<span class="token punctuation">[</span>amount<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="例题实战" tabindex="-1"><a class="header-anchor" href="#例题实战" aria-hidden="true">#</a> 例题实战</h2><h3 id="爬楼梯" tabindex="-1"><a class="header-anchor" href="#爬楼梯" aria-hidden="true">#</a> 爬楼梯</h3><p>下面介绍先通过典型的动态规划题目总结 <strong>计算步骤</strong>，然后利用计算步骤完成动态规划的题目。</p><p>假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p>如 n = 2 时，有两种方法，分别是：</p><ul><li>1 阶 + 1 阶</li><li>直接 2 阶</li></ul><p>如 n = 3，有三种方法，分别是：</p><ul><li>1 阶 + 1 阶 + 1 阶</li><li>1 阶 + 2 阶</li><li>2 阶 + 1 阶</li></ul><h4 id="计算步骤" tabindex="-1"><a class="header-anchor" href="#计算步骤" aria-hidden="true">#</a> 计算步骤</h4><ul><li><strong>特例确定</strong>，也就是「剪枝」，判断满足某些条件，直接返回，不需要计算，一般针对起始位置或末尾位置</li><li><strong>状态定义</strong>：定义状态的空间位置，确保动态规划有足够的空间存放子问题的解，如下题 f[i] 代表走过 i 阶需要的总方法</li><li><strong>初始状态</strong>，动态规划自底向上，所以底部（0 或者 1）至少要有一个已知的值，然后慢慢推到后面的值</li><li><strong>状态转移方程</strong>，动态规划最难的就是求解出状态转移方程，这是一种递推规律的公式</li><li><strong>返回值</strong>：确定最终的返回值</li></ul><h4 id="简单动态规划" tabindex="-1"><a class="header-anchor" href="#简单动态规划" aria-hidden="true">#</a> 简单动态规划</h4><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">climbStairs</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 特例</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">&lt;=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> n<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 确定空间</span>
  <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> f <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token comment">// 初始条件</span>
  f<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// -1 才是没有楼梯</span>
  f<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
  <span class="token comment">// 转移方程</span>
  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> f<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    f<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> f<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> f<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> f<span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="优化动态规划" tabindex="-1"><a class="header-anchor" href="#优化动态规划" aria-hidden="true">#</a> 优化动态规划</h4><p>因为我们只需要 3 中状态，也就是只需要 3 种子问题的解，即 n、n - 1、n - 2，其他的不需要，所以就利用变量来替换</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">climbStairs</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> p <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> q <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> r <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        p <span class="token operator">=</span> q<span class="token punctuation">;</span> 
        q <span class="token operator">=</span> r<span class="token punctuation">;</span> 
        r <span class="token operator">=</span> p <span class="token operator">+</span> q<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> r<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="最小路径和" tabindex="-1"><a class="header-anchor" href="#最小路径和" aria-hidden="true">#</a> 最小路径和</h3><p>题目来自 <code>https://leetcode-cn.com/problems/minimum-path-sum/</code></p><p>解题思路参考：<code>https://leetcode-cn.com/problems/minimum-path-sum/solution/zui-xiao-lu-jing-he-dong-tai-gui-hua-gui-fan-liu-c/</code></p><p><code>题目</code></p><ul><li>给定一个包含非负整数的 <code>m x n</code> 网格 <code>grid</code> ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小</li><li><strong>说明</strong>：每次只能向下或者向右移动一步</li></ul><p>示例 1：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>输入：grid = [[1,3,1],[1,5,1],[4,2,1]]
输出：7
解释：因为路径 1→3→1→1→1 的总和最小。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>示例 2：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>输入：grid = [[1,2,3],[4,5,6]]
输出：12
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>此题是典型的动态规划题目。</p><p>下面按动态规划的步骤进行计算：</p><p><code>特例确定</code></p><p>如果 DP 长度为 0，返回 0。</p><p><code>状态定义</code></p><p>设 DP 为大小 <code>m x n</code> 矩阵，其中 <code>dp[i][j]</code> 的值代表直到走到 (i,j) 的最小路径和。</p><p><code>初始状态</code></p><p>DP 初始化即可，不需要赋初始值。</p><p><code>状态转移方程</code></p><p>题目要求，只能向右或向下走，换句话说，当前单元格 (i, j) 只能从左方单元格 (i−1, j) 或上方单元格 (i, j−1) 走到，因此只需要考虑矩阵左边界和上边界。</p><p>走到当前单元格 (i, j) 的最小路径和 =「从左方单元格 (i-1, j) 与从上方单元格 (i, j−1) 走来的两个最小路径和中较小的」 + 当前单元格值 <code>dp[i][j]</code> 。具体分为以下 3 种情况：</p><ul><li>矩阵的第一列进行求和，然后覆盖原来的值。</li></ul><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>矩阵的第一行进行求和，然后覆盖原来的值。</li></ul><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code>dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li><strong>当左边和上边都不是矩阵边界时</strong>： 即当 i、j 不等于 0 时，有</li></ul><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><code>返回值</code></p><p>返回 DP 矩阵右下角值，即走到终点的最小路径和。</p><p><code>复杂度分析</code></p><p>时间复杂度 O(M x N)：遍历整个 grid 矩阵元素。</p><p>空间复杂度 O(1)：直接修改原矩阵，不使用额外空间。</p><p>grid 代表 DP</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>
  <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">minPathSum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> grid<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> high <span class="token operator">=</span> grid<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
    <span class="token keyword">int</span> width <span class="token operator">=</span> grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>width <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 先将矩阵 [0] 的左右进行叠加</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> high<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+=</span> grid<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> width<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> high<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> width<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>grid<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> grid<span class="token punctuation">[</span>high <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>width <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="不同路径" tabindex="-1"><a class="header-anchor" href="#不同路径" aria-hidden="true">#</a> 不同路径</h3><p>题目来自：<code>https://leetcode-cn.com/problems/unique-paths/</code></p><p><code>题目</code></p><ul><li>一个机器人位于一个 m x n 网格的左上角</li><li>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角，即 m x n 的终点（对角线的末尾）</li><li>问总共有多少条不同的路径？</li></ul><p>下面按动态规划的步骤进行计算：</p><p><code>特例确定</code></p><p>无特例。</p><p><code>初始状态</code></p><p>DP 初始化即可，不需要赋初始值。</p><p><code>状态定义</code></p><p>设 m x n 矩阵有 <code>dp[i][j]</code>，其中 i 代表矩阵的第 i 行，j 代表第 j 列。</p><p><code>状态转移方程</code></p><p>规律：</p><ul><li>如果位置处于第一行或者第一列，则总路径 = 1</li><li>不在第一行或者第一列，则某个位置的总路径 = 它上面位置的总路径 + 它左侧位置的总路径</li></ul><p>状态转移方程为：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code>dp<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><code>返回值</code></p><p>返回 DP 矩阵右下角值，即走到终点的总路径和。</p><p><code>复杂度分析</code></p><p>时间复杂度 O(m x n)：遍历整个 DP 矩阵元素。</p><p>空间复杂度 O(n)：直接修改原矩阵，不使用额外空间。</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">uniquePaths</span><span class="token punctuation">(</span><span class="token keyword">int</span> m<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 起始点为 0，如果在起始点的左侧或者右侧，那么就只有一条路径</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> j <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token comment">// 每条路径的次数都是从上方的路径和左侧的路径相加而得到，具体画图</span>
      <span class="token keyword">else</span> <span class="token punctuation">{</span>
        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 返回最后一个元素，数组从 0 开始</span>
  <span class="token keyword">return</span> dp<span class="token punctuation">[</span>m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="适用场景" tabindex="-1"><a class="header-anchor" href="#适用场景" aria-hidden="true">#</a> 适用场景</h2><p>适合用动态规划来解决的问题，都具有下面三个特点：最优化原理、最优化原理、有重叠子问题。</p><p>如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理。某阶段状态（定义的新子问题）一旦确定，就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响以前的状态，只与其以前的状态有关。子问题之间是不独立的（分治法是独立的），一个子问题在下一阶段决策中可能被多次使用到。（该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势）。</p><h2 id="算法局限" tabindex="-1"><a class="header-anchor" href="#算法局限" aria-hidden="true">#</a> 算法局限</h2><p>动态规划对于解决多阶段决策问题的效果是明显的，但是动态规划也有一定的局限性。首先，它没有统一的处理方法，必须根据问题的各种性质并结合一定的技巧来处理；另外当变量的维数增大时，总的计算量及存贮量急剧增大。因而，受计算机的存贮量及计算速度的限制，当今的计算机仍不能用动态规划方法来解决较大规模的问题，这就是「维数障碍」。</p><p>动态规划大部分都是 <strong>空间换时间</strong>，因为动态规划需要一个 DP 来存已经计算的子问题的解，所以需要利用大量的空间来存解值，但是在时间上就很快找出该解值，不需要重新求解值。</p></div><!----><footer class="page-meta"><div class="meta-item edit-link"><a href="https://gitee.com/jin-shaohui/jin-shaohui/edit/main/src/Algorithm/DynamicProgram/index.md" rel="noopener noreferrer" target="_blank" aria-label="编辑此页" class="nav-link label"><!--[--><svg xmlns="http://www.w3.org/2000/svg" class="icon edit-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="edit icon"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></svg><!--]-->编辑此页<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></div><div class="meta-item update-time"><span class="label">上次编辑于: </span><span class="info">2022/9/16 15:30:02</span></div><div class="meta-item contributors"><span class="label">贡献者: </span><!--[--><!--[--><span class="contributor" title="email: 1051131737@qq.com">靳少辉</span><!--]--><!--]--></div></footer><nav class="page-nav"><a href="/sla-blog/Algorithm/Dichotomy/" class="nav-link prev" aria-label="二分查找理论"><div class="hint"><span class="arrow left"></span>上一页</div><div class="link"><!---->二分查找理论</div></a><a href="/sla-blog/Algorithm/PriorityTraversal/" class="nav-link next" aria-label="优先遍历算法"><div class="hint">下一页<span class="arrow right"></span></div><div class="link">优先遍历算法<!----></div></a></nav><!----><!----><!--]--></main><!--]--><footer class="footer-wrapper"><div class="footer"></div><div class="copyright">MIT Licensed | Copyright © 2019-present JSH</div></footer><!--]--></div><!--]--><!----><!--]--></div>
    <script type="module" src="/sla-blog/assets/app.c75fd66b.js" defer></script>
  </body>
</html>
