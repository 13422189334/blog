<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>动态规划算法 | 繁华中自律，落魄中自愈</title>
    <meta name="generator" content="VuePress 1.9.7">
    <link rel="stylesheet" href="https://at.alicdn.com/t/font_3077305_pt8umhrn4k9.css">
    <link rel="javascript" href="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
    <link rel="stylesheet" href="//at.alicdn.com/t/font_3114978_qe0b39no76.css">
    <meta name="description" content="Just playing around">
    <meta name="referrer" content="no-referrer-when-downgrade">
    
    <link rel="preload" href="/assets/css/0.styles.fbab903f.css" as="style"><link rel="preload" href="/assets/js/app.91a5646d.js" as="script"><link rel="preload" href="/assets/js/3.37c6ddef.js" as="script"><link rel="preload" href="/assets/js/32.a469647c.js" as="script"><link rel="preload" href="/assets/js/23.5c68b32e.js" as="script"><link rel="preload" href="/assets/js/8.7677a8f4.js" as="script"><link rel="prefetch" href="/assets/js/10.b60712f5.js"><link rel="prefetch" href="/assets/js/11.f3410cec.js"><link rel="prefetch" href="/assets/js/12.5492e2c7.js"><link rel="prefetch" href="/assets/js/13.e705d504.js"><link rel="prefetch" href="/assets/js/14.f4834b41.js"><link rel="prefetch" href="/assets/js/15.04bca8c7.js"><link rel="prefetch" href="/assets/js/16.4266f945.js"><link rel="prefetch" href="/assets/js/17.7a23bb01.js"><link rel="prefetch" href="/assets/js/18.27866604.js"><link rel="prefetch" href="/assets/js/19.0aa08f7e.js"><link rel="prefetch" href="/assets/js/20.8b264979.js"><link rel="prefetch" href="/assets/js/21.16971cff.js"><link rel="prefetch" href="/assets/js/22.784adc59.js"><link rel="prefetch" href="/assets/js/24.8bab67e9.js"><link rel="prefetch" href="/assets/js/25.9857e2f5.js"><link rel="prefetch" href="/assets/js/26.cf28f2fb.js"><link rel="prefetch" href="/assets/js/27.c2dbdc68.js"><link rel="prefetch" href="/assets/js/28.9288eec9.js"><link rel="prefetch" href="/assets/js/29.c6f3c468.js"><link rel="prefetch" href="/assets/js/30.b5264f41.js"><link rel="prefetch" href="/assets/js/31.61769b6a.js"><link rel="prefetch" href="/assets/js/33.14410559.js"><link rel="prefetch" href="/assets/js/34.0e2b569e.js"><link rel="prefetch" href="/assets/js/35.1d971ab1.js"><link rel="prefetch" href="/assets/js/36.221b4a45.js"><link rel="prefetch" href="/assets/js/37.944ab6fc.js"><link rel="prefetch" href="/assets/js/38.1d912ab7.js"><link rel="prefetch" href="/assets/js/39.ccdd98b9.js"><link rel="prefetch" href="/assets/js/4.17e6d213.js"><link rel="prefetch" href="/assets/js/40.e286cb81.js"><link rel="prefetch" href="/assets/js/41.ae9d8e65.js"><link rel="prefetch" href="/assets/js/42.9f7ab87d.js"><link rel="prefetch" href="/assets/js/43.0647c6f6.js"><link rel="prefetch" href="/assets/js/44.5b212f31.js"><link rel="prefetch" href="/assets/js/45.8ef2d77a.js"><link rel="prefetch" href="/assets/js/46.ad1abfff.js"><link rel="prefetch" href="/assets/js/47.f7e3154d.js"><link rel="prefetch" href="/assets/js/48.eb6c6ce2.js"><link rel="prefetch" href="/assets/js/49.31e67e83.js"><link rel="prefetch" href="/assets/js/5.7cded8bb.js"><link rel="prefetch" href="/assets/js/50.85551832.js"><link rel="prefetch" href="/assets/js/51.f3cb9d6c.js"><link rel="prefetch" href="/assets/js/52.170dd065.js"><link rel="prefetch" href="/assets/js/53.79e2aae3.js"><link rel="prefetch" href="/assets/js/54.0cefdc6f.js"><link rel="prefetch" href="/assets/js/55.5d23fda8.js"><link rel="prefetch" href="/assets/js/56.4aa9df1b.js"><link rel="prefetch" href="/assets/js/57.7b22808c.js"><link rel="prefetch" href="/assets/js/58.23a2091f.js"><link rel="prefetch" href="/assets/js/59.5c3f52e8.js"><link rel="prefetch" href="/assets/js/6.ee083af8.js"><link rel="prefetch" href="/assets/js/60.db9673d6.js"><link rel="prefetch" href="/assets/js/61.3774e0ef.js"><link rel="prefetch" href="/assets/js/62.20a17c31.js"><link rel="prefetch" href="/assets/js/63.96bb2f0d.js"><link rel="prefetch" href="/assets/js/64.c3104420.js"><link rel="prefetch" href="/assets/js/65.274226aa.js"><link rel="prefetch" href="/assets/js/66.3f81a383.js"><link rel="prefetch" href="/assets/js/67.a373dea6.js"><link rel="prefetch" href="/assets/js/68.89e327f1.js"><link rel="prefetch" href="/assets/js/69.b59f1869.js"><link rel="prefetch" href="/assets/js/7.21851d68.js"><link rel="prefetch" href="/assets/js/70.1878e3b9.js"><link rel="prefetch" href="/assets/js/71.a927920b.js"><link rel="prefetch" href="/assets/js/72.6b32cc7a.js"><link rel="prefetch" href="/assets/js/73.9283b64f.js"><link rel="prefetch" href="/assets/js/74.d495e37f.js"><link rel="prefetch" href="/assets/js/75.aff92c33.js"><link rel="prefetch" href="/assets/js/76.8957d275.js"><link rel="prefetch" href="/assets/js/77.b8b6d67e.js"><link rel="prefetch" href="/assets/js/78.d834392c.js"><link rel="prefetch" href="/assets/js/79.d1e290d7.js"><link rel="prefetch" href="/assets/js/9.507d4e38.js"><link rel="prefetch" href="/assets/js/vendors~docsearch.b4252dbb.js">
    <link rel="stylesheet" href="/assets/css/0.styles.fbab903f.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/logo.jpg" alt="繁华中自律，落魄中自愈" class="logo"> <span class="site-name can-hide">繁华中自律，落魄中自愈</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><a href="/Knowledge/" class="nav-link">知识库</a></div><div class="nav-item"><a href="/DesignPattern/" class="nav-link">设计模式</a></div><div class="nav-item"><a href="/Algorithm/Dichotomy/" class="nav-link">常用算法</a></div><div class="nav-item"><a href="/Git/" class="nav-link">Git</a></div><div class="nav-item"><a href="/Server/" class="nav-link">服务器</a></div><div class="nav-item"><a href="/Performance/Info/" class="nav-link">性能优化</a></div><div class="nav-item"><a href="/Recommend/" class="nav-link">推荐</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><div class="blogger"><img src="/bingbing.jpg"> <div class="blogger-info"><h3>石怜安</h3> <span>在线找大长腿小姐姐</span></div></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><a href="/Knowledge/" class="nav-link">知识库</a></div><div class="nav-item"><a href="/DesignPattern/" class="nav-link">设计模式</a></div><div class="nav-item"><a href="/Algorithm/Dichotomy/" class="nav-link">常用算法</a></div><div class="nav-item"><a href="/Git/" class="nav-link">Git</a></div><div class="nav-item"><a href="/Server/" class="nav-link">服务器</a></div><div class="nav-item"><a href="/Performance/Info/" class="nav-link">性能优化</a></div><div class="nav-item"><a href="/Recommend/" class="nav-link">推荐</a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/Algorithm/Dichotomy/" class="sidebar-link">二分查找理论</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level2"><a href="/Algorithm/Dichotomy/#二分查找理论" class="sidebar-link">二分查找理论</a></li><li class="sidebar-sub-header level2"><a href="/Algorithm/Dichotomy/#方式" class="sidebar-link">方式</a></li><li class="sidebar-sub-header level2"><a href="/Algorithm/Dichotomy/#分类" class="sidebar-link">分类</a></li><li class="sidebar-sub-header level2"><a href="/Algorithm/Dichotomy/#实战" class="sidebar-link">实战</a></li></ul></li><li><a href="/Algorithm/DynamicProgram/" aria-current="page" class="active sidebar-link">动态规划算法</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level2"><a href="/Algorithm/DynamicProgram/#算法认识" class="sidebar-link">算法认识</a></li><li class="sidebar-sub-header level2"><a href="/Algorithm/DynamicProgram/#算法性质" class="sidebar-link">算法性质</a></li><li class="sidebar-sub-header level2"><a href="/Algorithm/DynamicProgram/#步骤实战" class="sidebar-link">步骤实战</a></li><li class="sidebar-sub-header level2"><a href="/Algorithm/DynamicProgram/#例题实战" class="sidebar-link">例题实战</a></li><li class="sidebar-sub-header level2"><a href="/Algorithm/DynamicProgram/#适用场景" class="sidebar-link">适用场景</a></li><li class="sidebar-sub-header level2"><a href="/Algorithm/DynamicProgram/#算法局限" class="sidebar-link">算法局限</a></li></ul></li><li><a href="/Algorithm/PriorityTraversal/" class="sidebar-link">优先遍历算法</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level2"><a href="/Algorithm/PriorityTraversal/#深度优先遍历" class="sidebar-link">深度优先遍历</a></li><li class="sidebar-sub-header level2"><a href="/Algorithm/PriorityTraversal/#广度优先遍历" class="sidebar-link">广度优先遍历</a></li></ul></li></ul> </aside> <div><main class="page"><div class="theme-vdoing-wrapper bg-style-6"><div class="articleInfo-wrap" data-v-1baff76c><div class="articleInfo" data-v-1baff76c><ul class="breadcrumbs" data-v-1baff76c><li data-v-1baff76c><a href="/" title="首页" class="iconfont icon-home router-link-active" data-v-1baff76c></a></li> <li data-v-1baff76c><a href="/categories/?category=Algorithm" title="分类" data-v-1baff76c>Algorithm</a></li><li data-v-1baff76c><a href="/categories/?category=DynamicProgram" title="分类" data-v-1baff76c>DynamicProgram</a></li></ul> <div class="info" data-v-1baff76c><div title="作者" class="author iconfont icon-touxiang" data-v-1baff76c><a href="404" target="_blank" title="作者" class="beLink" data-v-1baff76c>JSH</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-1baff76c><a href="javascript:;" data-v-1baff76c>2022-06-06</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-title">目录</div> <div class="right-menu-content"></div></div></div> <h1><img src="/bingbing.jpg">动态规划算法<!----></h1>  <div class="theme-vdoing-content content__default"><h2 id="算法认识"><a href="#算法认识" class="header-anchor">#</a> 算法认识</h2> <p>动态规划（Dynamic Programming）简称 DP，对于子问题重叠的情况特别有效，因为它将子问题的解保存在表格中，当需要某个子问题的解时，直接取值即可，从而避免重复计算。</p> <p>动态规划算法通常用于求解具有某种最优性质的问题。在这类问题中，可能会有许多可行解。每一个解都对应于一个值，我们希望找到具有最优值的解。</p> <p>动态规划算法与分治法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。</p> <p>与分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的。若用分治法来解这类问题，则分解得到的子问题数目太多，有些子问题被重复计算了很多次。如果我们能够保存已解决的子问题的答案，而在需要时再找出已求得的答案，这样就可以避免大量的重复计算，节省时间。我们可以用一个表来记录所有已解的子问题的答案。不管该子问题以后是否被用到，只要它被计算过，就将其结果填入表中。</p> <p>所以动态规划实际上是将问题分化成很多的子问题，然后将当前子问题计算过的最优结果存储起来，当另一个子问题也打算求该结果时，直接返回即可，因为已经是最优解。</p> <p>动态规划的题目分为两大类，一种是求最优解类，典型问题是背包问题，另一种就是计数类，它们都存在一定的递推性质。前者的递推性质还有一个名字，叫做 「最优子结构」 ——即当前问题的最优解取决于子问题的最优解，后者类似，当前问题的方案数取决于子问题的方案数。所以在遇到求方案数的问题时，我们可以往动态规划的方向考虑。</p> <h2 id="算法性质"><a href="#算法性质" class="header-anchor">#</a> 算法性质</h2> <p>动态规划有很多的「高大上」的术语和性质，这些性质也是算法需要考虑的步骤。</p> <div class="custom-block danger"><p class="custom-block-title">警告</p> <p>子问题重叠</p></div> <p>子问题重叠性质是指在用递归算法自顶向下对问题进行求解时，每次产生的子问题并不总是新问题，有些子问题会被重复计算多次。动态规划算法正是利用了这种子问题的重叠性质，对每一个子问题只计算一次，然后将其计算结果保存在一个表格中，当再次需要计算已经计算过的子问题时，只是在表格中简单地查看一下结果，从而获得较高的效率。</p> <p>也就是在求解的过程中，许多子问题的解被反复地使用。为了避免重复计算，动态规划算法采用了填表来保存子问题解。</p> <div class="custom-block danger"><p class="custom-block-title">警告</p> <p>状态转移方程</p></div> <p><strong>动态规划最难的就是求解出状态转移方程</strong>，就类似于递推的公式，如：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">f</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">f</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span>  <span class="token comment">// n 是 1,2,...,n</span>
dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">]</span>  <span class="token comment">// // i 是 1,2,...,i</span>
</code></pre></div><p>其中 <code>f(n)</code> 由 <code>f(n - 1)</code> 和 <code>f(n - 2)</code> 不断转移，直至 n 才得到结果，这就是状态转移方程。</p> <div class="custom-block danger"><p class="custom-block-title">警告</p> <p>最优子结构</p></div> <p>如果问题的最优解所包含的子问题的解也是最优的，我们就称该问题具有最优子结构性质（即满足最优化原理）。</p> <p>原问题的解是由多个子问题的最优解构成，比如说，原问题是考出最高的总成绩，那么子问题就是要把语文考到最高，数学考到最高等，为了每门课考到最高，要把每门课相应的选择题分数拿到最高，填空题分数拿到最高等等，当然，最终就是每门课都是满分，这就是最高的总成绩。所以得到了最后正确的结果：最高的总成绩就是总分。</p> <div class="custom-block danger"><p class="custom-block-title">警告</p> <p>无后效性</p></div> <p>即某阶段状态一旦确定，就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关。</p> <p>如 A -&gt; B -&gt; C，那么 B 和 C 的结果不会影响 A，同理 C 不会影响 B，但是 A 能影响 B 和 C，毕竟 B 和 C 是通过 A 的结果来算出。</p> <div class="custom-block danger"><p class="custom-block-title">警告</p> <p>自底向上</p></div> <p>动态规划的特点就是从最底部（0 或者 1）蔓延到上面（n），假设存在长度 n，我们知道递归是从 n 到 n - 1 往下遍历，直至到 1，这叫 <strong>自顶向下</strong>。而动态规划是 <strong>自底向上</strong>，也就是从 1 到 2 往上遍历，直至到 n。</p> <div class="custom-block danger"><p class="custom-block-title">警告</p> <p>初始条件</p></div> <p>因为动态规划是自底向上，所以我们在求解的时候需要由一些原始条件，如：</p> <div class="language-js extra-class"><pre class="language-js"><code>dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
</code></pre></div><p>这样才有具体的值来自底向上：</p> <div class="language-js extra-class"><pre class="language-js"><code>dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="步骤实战"><a href="#步骤实战" class="header-anchor">#</a> 步骤实战</h2> <p>动态规划遵循一套固定的流程：<strong>递归的暴力解法</strong> -&gt; <strong>带备忘录的递归解法</strong> -&gt; <strong>非递归的动态规划解法</strong>。这个过程是层层递进的解决问题的过程，如果没有前面的铺垫，直接看最终的非递归的动态规划解法，会难理解。</p> <h3 id="斐波那契式子"><a href="#斐波那契式子" class="header-anchor">#</a> 斐波那契式子</h3> <p>斐波那契式子为：<code>F(0) = 0，F(1) = 1, F(n) = F(n - 1) + F(n - 2)</code>。</p> <div class="custom-block danger"><p class="custom-block-title">警告</p> <p>暴力的递归算法</p></div> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">fib</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">||</span> n <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token function">fib</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">fib</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 自顶向下</span>
<span class="token punctuation">}</span>
</code></pre></div><p>要想计算原问题 f(20)，就得先计算出子问题 f(19) 和 f(18)，然后要计算 f(19)，我就要先算出子问题 f(18) 和 f(17)，依次类推。最后遇到 f(1) 或者 f(2) 的时候，结果已知，就能直接返回结果。</p> <p>子问题个数为 O(2^n)，所以这个算法的时间复杂度为 O(2^n)，效率很低。</p> <p>这就是我们需要解决动态规划问题的第一个性质：<strong>重叠子问题</strong></p> <div class="custom-block danger"><p class="custom-block-title">警告</p> <p>步骤二、带备忘录的递归解法</p></div> <p>即然耗时的原因是重复计算，那么我们可以造一个「备忘录」，每次算出某个子问题的答案后别急着返回，先记到「备忘录」里再返回；后面每次遇到一个子问题先去「备忘录」里查一查，如果发现之前已经解决过这个问题了，直接把答案拿出来用，不要再耗时去计算了。</p> <p>「备忘录」可以是数组，也可以是哈希表，key 为子问题的唯一标识，value 就是解决后的结果。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">fib</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 备忘录全初始化为 0</span>
  <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> memo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  memo<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  memo<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token comment">// 初始化最简情况</span>
  <span class="token function">fibMemo</span><span class="token punctuation">(</span>memo<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> memo<span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 1 1 2 3 5 8 13，因为 i 从 0 开始，所以 n - 1 就是结果</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">fibMemo</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> memo<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 未被计算过</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> memo<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    memo<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">fibMemo</span><span class="token punctuation">(</span>memo<span class="token punctuation">,</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">fibMemo</span><span class="token punctuation">(</span>memo<span class="token punctuation">,</span> n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> memo<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>带「备忘录」的递归算法，把一棵存在巨量冗余的递归树通过「剪枝」，改造成了一幅不存在冗余的递归图，极大减少了子问题（即递归图中节点）的个数。</p> <p>子问题个数为 O(n)。所以，本算法的时间复杂度是 O(n)。比起暴力算法，效率大幅度提升很多。</p> <p>至此，带备忘录的递归解法的效率已经和动态规划一样了。实际上，这种解法和动态规划的思想已经差不多了，只不过这种方法叫做「自顶向下」，动态规划叫做「自底向上」，这也是为什么动态规划一般都脱离了递归，而是由循环迭代完成计算。</p> <div class="custom-block danger"><p class="custom-block-title">警告</p> <p>动态规划</p></div> <p>有「备忘录」的启发，我们可以把这个「备忘录」独立出来成为一张表，叫做 dp，在这张表上完成「自底向上」的推算。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">fib</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 状态转移方程</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 1 1 2 3 5 8 13，因为 i 从 0 开始，所以 n - 1 就是结果</span>
<span class="token punctuation">}</span>

</code></pre></div><p><code>dp[i] = dp[i - 1] + dp[i - 2];</code> 就是 <strong>状态转移方程</strong>，它是解决问题的核心。我们也很容易发现，其实状态转移方程直接代表着暴力解法。</p> <p><strong>动态规划问题最困难的就是写出状态转移方程</strong>。</p> <blockquote><p>动态规划优化</p></blockquote> <p>根据斐波那契数列的状态转移方程，当前状态只和之前的两个状态有关，其实并不需要那么长的一个 dp 来存储所有的状态，只要想办法存储之前的两个状态就行了。所以，可以进一步优化，把空间复杂度降为 O(1)：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">fib</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> n<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">int</span> prev <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> curr <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> sum <span class="token operator">=</span> prev <span class="token operator">+</span> curr<span class="token punctuation">;</span>
    prev <span class="token operator">=</span> curr<span class="token punctuation">;</span>
    curr <span class="token operator">=</span> sum<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> curr<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="硬币凑钱"><a href="#硬币凑钱" class="header-anchor">#</a> 硬币凑钱</h3> <p>给 k 种面值的硬币，面值分别为 c1，c2，...，ck，再给一个总金额 n，问最少需要几枚硬币凑出这个金额，如果不可能凑出，则回答 -1 。</p> <p>比如说，k = 3，面值分别为 1，2，5，总金额 n = 11，那么最少需要 3 枚硬币，即 <code>11 = 5 + 5 + 1</code>。</p> <div class="custom-block danger"><p class="custom-block-title">警告</p> <p>暴力的递归算法</p></div> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">coinChange</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> coins<span class="token punctuation">,</span> <span class="token keyword">int</span> amount<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>amount <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> coin <span class="token operator">:</span> coins<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 金额不可达</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>amount <span class="token operator">-</span> coin <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">continue</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">int</span> subProb <span class="token operator">=</span> <span class="token function">coinChange</span><span class="token punctuation">(</span>coins<span class="token punctuation">,</span> amount <span class="token operator">-</span> coin<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 子问题无解时</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>subProb <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">continue</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    ans <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>ans<span class="token punctuation">,</span> subProb <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> ans <span class="token operator">==</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>MAX_VALUE <span class="token operator">?</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">:</span> ans<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>总时间复杂度为 O(k*n^k)。</p> <p>:::damger
带备忘录的递归算法
:::</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">coinChange</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> coins<span class="token punctuation">,</span> <span class="token keyword">int</span> amount<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 备忘录初始化为 -2</span>
  <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> memo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>amount <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span>memo<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  
  <span class="token keyword">return</span> <span class="token function">helper</span><span class="token punctuation">(</span>coins<span class="token punctuation">,</span> amount<span class="token punctuation">,</span> memo<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">helper</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> coins<span class="token punctuation">,</span> <span class="token keyword">int</span> amount<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> memo<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>amount <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 备忘录不为 -2 代表已经存有最优解</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>memo<span class="token punctuation">[</span>amount<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> memo<span class="token punctuation">[</span>amount<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> coin <span class="token operator">:</span> coins<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 金额不可达</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>amount <span class="token operator">-</span> coin <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">continue</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">int</span> subProb <span class="token operator">=</span> <span class="token function">helper</span><span class="token punctuation">(</span>coins<span class="token punctuation">,</span> amount <span class="token operator">-</span> coin<span class="token punctuation">,</span> memo<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 子问题无解时</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>subProb <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">continue</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    ans <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>ans<span class="token punctuation">,</span> subProb <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 记录本轮答案，下标就是凑够当前硬币的最少枚次数</span>
  memo<span class="token punctuation">[</span>amount<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>ans <span class="token operator">==</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">:</span> ans<span class="token punctuation">;</span>
  <span class="token keyword">return</span> memo<span class="token punctuation">[</span>amount<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="custom-block danger"><p class="custom-block-title">警告</p> <p>动态规划</p></div> <p>如果我们有面值为 1 元、3 元和 5 元的硬币若干枚，如何用最少的硬币凑够 11 元？ (表面上这道题可以用贪心算法，但贪心算法无法保证可以求出解，比如 1 元换成 2 元的时候)</p> <p>如何用最少的硬币凑够i元（i &lt; 11）？ 两个原因：</p> <ul><li>当我们遇到一个大问题时，总是习惯把问题的规模变小，这样便于分析讨论</li> <li>这个规模变小后的问题和原来的问题是同质的，除了规模变小，其它的都是一样的， 本质上它还是同一个问题（规模变小后的问题其实是原问题的子问题）</li></ul> <p>当 i = 0，即需要多少个硬币来凑够 0 元。 由于 1，3，5 都大于 0，即没有比 0 小的币值，因此凑够 0 元最少需要 0 个硬币。这时候可以用一个 <strong>标记</strong> 来表示「凑够 0 元最少需要 0 个硬币」。</p> <p>那么， 我们用 <code>d(i) = j</code> 来表示凑够 i 元最少需要 j 个硬币。于是我们已经得到了 <code>d(0) = 0</code>，表示凑够 0 元最小需要 0 个硬币。</p> <p>当 i = 1 时，只有面值为 1 元的硬币可用，因此我们拿起一个面值为 1 的硬币，接下来只需要凑够 0 元即可，即 <code>d(0) = 0</code>。所以有：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token function">d</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">d</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">=</span> <span class="token function">d</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">=</span> <span class="token number">0</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">=</span> <span class="token number">1</span>
</code></pre></div><p>当 i = 2 时，仍然只有面值为 1 的硬币可用，于是我拿起一个面值为 1 的硬币，接下来我只需要再凑够 2 - 1 = 1 元即可， 所以有：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token function">d</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">d</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">=</span> <span class="token function">d</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">=</span> <span class="token number">2</span>
</code></pre></div><p>当 i = 3 时，我们能用的硬币就有两种了：1 元和 3 元。既然能用的硬币有两种，于是就有两种方案。如果我拿了一个 1 元的硬币，我的目标就变为了： 凑够 3 - 1 = 2 元需要的最少硬币数量。即</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token function">d</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">d</span><span class="token punctuation">(</span><span class="token number">3</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">=</span> <span class="token function">d</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">=</span> <span class="token number">3</span>
</code></pre></div><p>这个方案说的是，我拿 3 个 1 元的硬币；第二种方案是我拿起一个 3 元的硬币，我的目标就变成：凑够 3 - 3 = 0元需要的最少硬币数量。即</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token function">d</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">d</span><span class="token punctuation">(</span><span class="token number">3</span> <span class="token operator">-</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">=</span> <span class="token function">d</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">=</span> <span class="token number">0</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">=</span> <span class="token number">1</span>
</code></pre></div><p>这个方案说的是，我拿 1 个 3 元的硬币。</p> <p>这两种方案哪种更优呢？题目要求使用用最少的硬币数量来凑够 3 元的。所以，选择 <code>d(3) = 1</code>，所以我们得到了 <strong>转移状态方程</strong>：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token function">d</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span><span class="token function">d</span><span class="token punctuation">(</span><span class="token number">3</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token function">d</span><span class="token punctuation">(</span><span class="token number">3</span> <span class="token operator">-</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>从以上的文字中， 我们要得到动态规划里非常重要的两个概念：<strong>状态</strong> 和 <strong>状态转移方程</strong>。</p> <p>上文中 d(i) 表示凑够 i 元需要的最少硬币数量，我们将它定义为该问题的 <strong>状态</strong>， 这个状态是怎么找出来的呢？要根据子问题定义状态，找到子问题，状态也就浮出水面了。最终我们要求解的问题，可以用这个状态来表示：d(11)，即凑够 11 元最少需要多少个硬币。</p> <p>那状态转移方程是什么呢？既然我们用 d(i) 表示状态，那么状态转移方程应该包含了状态 d(i)，上文中包含状态 d(i) 的方程是：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token function">d</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span><span class="token function">d</span><span class="token punctuation">(</span><span class="token number">3</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token function">d</span><span class="token punctuation">(</span><span class="token number">3</span> <span class="token operator">-</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>于是它就是状态转移方程，描述状态之间是如何转移的。当然，我们要对它抽象一下，</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token function">d</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span><span class="token function">d</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">d</span><span class="token punctuation">(</span>i <span class="token operator">-</span> vj<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 其中 i-vj &gt;= 0，vj 表示第 j 个硬币的面值</span>
</code></pre></div><p>所以最终代码：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">coinChange</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> coins<span class="token punctuation">,</span> <span class="token keyword">int</span> amount<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>amount <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span>dp<span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">)</span><span class="token punctuation">;</span>
    dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> dp<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 内层 for 在求所有子问题 + 1 的最小值</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> coin <span class="token operator">:</span> coins<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">-</span> coin <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">continue</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">1</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> coin<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 状态转移方程</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> dp<span class="token punctuation">[</span>amount<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>MAX_VALUE <span class="token operator">?</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">:</span> dp<span class="token punctuation">[</span>amount<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="例题实战"><a href="#例题实战" class="header-anchor">#</a> 例题实战</h2> <h3 id="爬楼梯"><a href="#爬楼梯" class="header-anchor">#</a> 爬楼梯</h3> <p>下面介绍先通过典型的动态规划题目总结 <strong>计算步骤</strong>，然后利用计算步骤完成动态规划的题目。</p> <p>假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p> <p>如 n = 2 时，有两种方法，分别是：</p> <ul><li>1 阶 + 1 阶</li> <li>直接 2 阶</li></ul> <p>如 n = 3，有三种方法，分别是：</p> <ul><li>1 阶 + 1 阶 + 1 阶</li> <li>1 阶 + 2 阶</li> <li>2 阶 + 1 阶</li></ul> <div class="custom-block danger"><p class="custom-block-title">警告</p> <p>计算步骤</p></div> <ul><li><strong>特例确定</strong>，也就是「剪枝」，判断满足某些条件，直接返回，不需要计算，一般针对起始位置或末尾位置</li> <li><strong>状态定义</strong>：定义状态的空间位置，确保动态规划有足够的空间存放子问题的解，如下题 f[i] 代表走过 i 阶需要的总方法</li> <li><strong>初始状态</strong>，动态规划自底向上，所以底部（0 或者 1）至少要有一个已知的值，然后慢慢推到后面的值</li> <li><strong>状态转移方程</strong>，动态规划最难的就是求解出状态转移方程，这是一种递推规律的公式</li> <li><strong>返回值</strong>：确定最终的返回值</li></ul> <div class="custom-block danger"><p class="custom-block-title">警告</p> <p>简单动态规划</p></div> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">climbStairs</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 特例</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">&lt;=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> n<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 确定空间</span>
  <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> f <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token comment">// 初始条件</span>
  f<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// -1 才是没有楼梯</span>
  f<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
  <span class="token comment">// 转移方程</span>
  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> f<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    f<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> f<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> f<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> f<span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="custom-block danger"><p class="custom-block-title">警告</p> <p>优化动态规划</p></div> <p>因为我们只需要 3 中状态，也就是只需要 3 种子问题的解，即 n、n - 1、n - 2，其他的不需要，所以就利用变量来替换</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">climbStairs</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> p <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> q <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> r <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        p <span class="token operator">=</span> q<span class="token punctuation">;</span> 
        q <span class="token operator">=</span> r<span class="token punctuation">;</span> 
        r <span class="token operator">=</span> p <span class="token operator">+</span> q<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> r<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="最小路径和"><a href="#最小路径和" class="header-anchor">#</a> 最小路径和</h3> <p>题目来自 <code>https://leetcode-cn.com/problems/minimum-path-sum/</code></p> <p>解题思路参考：<code>https://leetcode-cn.com/problems/minimum-path-sum/solution/zui-xiao-lu-jing-he-dong-tai-gui-hua-gui-fan-liu-c/</code></p> <p><code>题目</code></p> <ul><li>给定一个包含非负整数的 <code>m x n</code> 网格 <code>grid</code> ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小</li> <li><strong>说明</strong>：每次只能向下或者向右移动一步</li></ul> <p>示例 1：</p> <div class="language- extra-class"><pre class="language-text"><code>输入：grid = [[1,3,1],[1,5,1],[4,2,1]]
输出：7
解释：因为路径 1→3→1→1→1 的总和最小。
</code></pre></div><p>示例 2：</p> <div class="language- extra-class"><pre class="language-text"><code>输入：grid = [[1,2,3],[4,5,6]]
输出：12
</code></pre></div><p>此题是典型的动态规划题目。</p> <p>下面按动态规划的步骤进行计算：</p> <p><code>特例确定</code></p> <p>如果 DP 长度为 0，返回 0。</p> <p><code>状态定义</code></p> <p>设 DP 为大小 <code>m x n</code> 矩阵，其中 <code>dp[i][j]</code> 的值代表直到走到 (i,j) 的最小路径和。</p> <p><code>初始状态</code></p> <p>DP 初始化即可，不需要赋初始值。</p> <p><code>状态转移方程</code></p> <p>题目要求，只能向右或向下走，换句话说，当前单元格 (i, j) 只能从左方单元格 (i−1, j) 或上方单元格 (i, j−1) 走到，因此只需要考虑矩阵左边界和上边界。</p> <p>走到当前单元格 (i, j) 的最小路径和 =「从左方单元格 (i-1, j) 与从上方单元格 (i, j−1) 走来的两个最小路径和中较小的」 + 当前单元格值 <code>dp[i][j]</code> 。具体分为以下 3 种情况：</p> <ul><li>矩阵的第一列进行求和，然后覆盖原来的值。</li></ul> <div class="language-java extra-class"><pre class="language-java"><code>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>矩阵的第一行进行求和，然后覆盖原来的值。</li></ul> <div class="language-java extra-class"><pre class="language-java"><code>dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre></div><ul><li><strong>当左边和上边都不是矩阵边界时</strong>： 即当 i、j 不等于 0 时，有</li></ul> <div class="language-java extra-class"><pre class="language-java"><code>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p><code>返回值</code></p> <p>返回 DP 矩阵右下角值，即走到终点的最小路径和。</p> <p><code>复杂度分析</code></p> <p>时间复杂度 O(M x N)：遍历整个 grid 矩阵元素。</p> <p>空间复杂度 O(1)：直接修改原矩阵，不使用额外空间。</p> <div class="custom-block danger"><p class="custom-block-title">警告</p> <p>代码</p></div> <p>grid 代表 DP</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>
  <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">minPathSum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> grid<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> high <span class="token operator">=</span> grid<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
    <span class="token keyword">int</span> width <span class="token operator">=</span> grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>width <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 先将矩阵 [0] 的左右进行叠加</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> high<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+=</span> grid<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> width<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> high<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> width<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>grid<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> grid<span class="token punctuation">[</span>high <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>width <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="不同路径"><a href="#不同路径" class="header-anchor">#</a> 不同路径</h3> <p>题目来自：<code>https://leetcode-cn.com/problems/unique-paths/</code></p> <p><code>题目</code></p> <ul><li>一个机器人位于一个 m x n 网格的左上角</li> <li>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角，即 m x n 的终点（对角线的末尾）</li> <li>问总共有多少条不同的路径？</li></ul> <p>下面按动态规划的步骤进行计算：</p> <p><code>特例确定</code></p> <p>无特例。</p> <p><code>初始状态</code></p> <p>DP 初始化即可，不需要赋初始值。</p> <p><code>状态定义</code></p> <p>设 m x n 矩阵有 <code>dp[i][j]</code>，其中 i 代表矩阵的第 i 行，j 代表第 j 列。</p> <p><code>状态转移方程</code></p> <p>规律：</p> <ul><li>如果位置处于第一行或者第一列，则总路径 = 1</li> <li>不在第一行或者第一列，则某个位置的总路径 = 它上面位置的总路径 + 它左侧位置的总路径</li></ul> <p>状态转移方程为：</p> <div class="language-java extra-class"><pre class="language-java"><code>dp<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre></div><p><code>返回值</code></p> <p>返回 DP 矩阵右下角值，即走到终点的总路径和。</p> <p><code>复杂度分析</code></p> <p>时间复杂度 O(m x n)：遍历整个 DP 矩阵元素。</p> <p>空间复杂度 O(n)：直接修改原矩阵，不使用额外空间。</p> <div class="custom-block danger"><p class="custom-block-title">警告</p> <p>代码</p></div> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">uniquePaths</span><span class="token punctuation">(</span><span class="token keyword">int</span> m<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 起始点为 0，如果在起始点的左侧或者右侧，那么就只有一条路径</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> j <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token comment">// 每条路径的次数都是从上方的路径和左侧的路径相加而得到，具体画图</span>
      <span class="token keyword">else</span> <span class="token punctuation">{</span>
        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 返回最后一个元素，数组从 0 开始</span>
  <span class="token keyword">return</span> dp<span class="token punctuation">[</span>m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="适用场景"><a href="#适用场景" class="header-anchor">#</a> 适用场景</h2> <p>适合用动态规划来解决的问题，都具有下面三个特点：最优化原理、最优化原理、有重叠子问题。</p> <p>如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理。某阶段状态（定义的新子问题）一旦确定，就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响以前的状态，只与其以前的状态有关。子问题之间是不独立的（分治法是独立的），一个子问题在下一阶段决策中可能被多次使用到。（该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势）。</p> <h2 id="算法局限"><a href="#算法局限" class="header-anchor">#</a> 算法局限</h2> <p>动态规划对于解决多阶段决策问题的效果是明显的，但是动态规划也有一定的局限性。首先，它没有统一的处理方法，必须根据问题的各种性质并结合一定的技巧来处理；另外当变量的维数增大时，总的计算量及存贮量急剧增大。因而，受计算机的存贮量及计算速度的限制，当今的计算机仍不能用动态规划方法来解决较大规模的问题，这就是「维数障碍」。</p> <p>动态规划大部分都是 <strong>空间换时间</strong>，因为动态规划需要一个 DP 来存已经计算的子问题的解，所以需要利用大量的空间来存解值，但是在时间上就很快找出该解值，不需要重新求解值。</p></div></div>  <div class="page-edit"><!----> <div class="tags"><a href="/tags/?tag=%E5%BE%88%E8%8F%9C%E7%9A%84%E7%AE%97%E6%B3%95" title="标签">#很菜的算法</a></div> <div class="last-updated"><span class="prefix">最近更新时间:</span> <span class="time">6/23/2022, 5:56:53 PM</span></div></div> <div class="page-nav-wapper"><div class="page-nav-centre-wrap"><a href="/Algorithm/Dichotomy/" class="page-nav-centre page-nav-centre-prev"><div class="tooltip">二分查找理论</div></a> <a href="/Algorithm/PriorityTraversal/" class="page-nav-centre page-nav-centre-next"><div class="tooltip">优先遍历算法</div></a></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/Algorithm/Dichotomy/" class="prev">二分查找理论</a></span> <span class="next"><a href="/Algorithm/PriorityTraversal/">优先遍历算法</a>→
      </span></p></div></div></div> <div class="article-list"><div class="article-title"><a href="/archives/" class="iconfont icon-bi">最近更新</a></div> <div class="article-wrapper"><dl><dd>01</dd> <dt><a href="/Vue3/ToolFunction/"><div>
            VUE3工具函数源码解析
            <!----></div></a> <span class="date">07-11</span></dt></dl><dl><dd>02</dd> <dt><a href="/Performance/info/"><div>
            浅谈性能优化
            <!----></div></a> <span class="date">06-30</span></dt></dl><dl><dd>03</dd> <dt><a href="/React/Hooks/"><div>
            浅谈12个Hooks
            <!----></div></a> <span class="date">06-27</span></dt></dl> <dl><dd></dd> <dt><a href="/archives/" class="more">更多文章&gt;</a></dt></dl></div></div></main></div> <div class="footer"><div class="icons"><a href="String" title="1051131737" target="_blank" class="iconfont icon-QQ"></a><a href="String" title="1051131737@qq.com" target="_blank" class="iconfont icon-youjian"></a><a href="String" title="jsh1051131737" target="_blank" class="iconfont icon-weixin"></a></div> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> 
    | Copyright © 2021-2022
    <span>JSH</span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <!----> <!----> <!----></div><div class="global-ui"><!----><div></div><div></div></div></div>
    <script src="/assets/js/app.91a5646d.js" defer></script><script src="/assets/js/3.37c6ddef.js" defer></script><script src="/assets/js/32.a469647c.js" defer></script><script src="/assets/js/23.5c68b32e.js" defer></script><script src="/assets/js/8.7677a8f4.js" defer></script>
  </body>
</html>
